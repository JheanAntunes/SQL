SQL

- Modelagem de dados
- Constru√ß√£o de Banco de Dados
- Interpreta√ß√£o e Extra√ß√£o de Dados
- Desempenho
- Manuten√ß√£o dos M√©todos e procedures
- Equipe do DBA

=== Fundamentos do Banco de dados.
- Introduction a banco de dados.
- Sistemas de Gerenciamento de banco de dados.
- Modelagem de Dados para banco de dados.
- Arquitetura de banco de dados.

= Banco de dados
- Neg√≥cios
- E-commerce
- Medicina
- Engenharia
- Social Media
- Database --> Conjunto de dados.
`
Um banco de dados √© um sistema utilizado para armazenar, organizar e gerenciar grandes volumes de dados de maneira eficiente e estruturada..
`
- Contexto --> representa√ß√£o do mundo real
- Coer√™ncia;
- Prop√≥sito

================ SGBDs ======================
# SGBDs --> Sistemas de Gerenciamento de Banco de dado.

- Recupera√ß√£o de Dados: Gerencia a forma como os dados s√£o armazenados fisicamente e fornece mecanismos para recuper√°-los rapidamente.

- Controle de Acesso: Garante que apenas usu√°rios autorizados possam acessar e modificar os dados, proporcionando seguran√ßa e integridade.

- Integridade de Dados: Assegura que os dados armazenados est√£o corretos e consistentes.

- Suporte a Transa√ß√µes: Garante que opera√ß√µes de banco de dados, chamadas de transa√ß√µes, sejam realizadas completamente ou n√£o sejam realizadas de forma alguma, mantendo a consist√™ncia do banco de dados.

- Administra√ß√£o de Dados: Fornece ferramentas para monitorar e otimizar o desempenho do banco de dados.

# Modelo Relacional
- Tabelas: Estruturas que armazenam dados em linhas e colunas.

- Chaves Prim√°rias: Campos que identificam unicamente cada registro em uma tabela.

- Chaves Estrangeiras: Campos que criam relacionamentos entre tabelas, ligando um campo de uma tabela a um campo correspondente de outra tabela.

- Normaliza√ß√£o: Processo de organizar dados para reduzir a redund√¢ncia e melhorar a integridade dos dados.

- SQL (Structured Query Language): Linguagem padr√£o usada para gerenciar e consultar bancos de dados relacionais.

## SGBDs Mais utilizado no Mercado.
- Oracle
- MySQL
- SQLServer
- PostgreSQL
- MongoDB 
- Redis

## SGBDs Natureza auto-descritiva
- Descri√ß√£o da estrutura e constrains
- DB schema 

## SGBDs Isolamento e abstra√ß√£o.
- Abstra√ß√£o --> independ√™ncia do programa e dados
- Transpar√™ncia  

## M√∫ltiplas Vis√µes dos dados.
` Em um contexto de SGBDs relacionais, m√∫ltiplas vis√µes dos dados referem-se √† capacidade de visualizar dados de diferentes maneiras para atender a necessidades espec√≠ficas. Isso pode ser realizado atrav√©s de`

- Views (Vis√µes): Consultas SQL armazenadas que apresentam dados espec√≠ficos de uma ou mais tabelas sem alterar os dados subjacentes.

- √çndices: Estruturas que melhoram a efici√™ncia das consultas e permitem acesso r√°pido a registros.

- Consultas Personalizadas: SQL permite a cria√ß√£o de consultas personalizadas para extrair e visualizar dados conforme necess√°rio.

- Relat√≥rios Din√¢micos: Ferramentas que geram relat√≥rios com base em crit√©rios definidos pelo usu√°rio.


## Compartilhamento de Dados
- O compartilhamento de dados √© uma das principais fun√ß√µes dos SGBDs. Ele permite que diferentes usu√°rios e aplica√ß√µes acessem os mesmos dados sem conflitos. Algumas das caracter√≠sticas importantes do compartilhamento de dados incluem:

- Controle de Concurrency: T√©cnicas como bloqueios e controle de vers√µes s√£o usadas para garantir que m√∫ltiplas transa√ß√µes possam ocorrer simultaneamente sem interfer√™ncias indesejadas.

- Isolamento: Cada transa√ß√£o opera como se fosse a √∫nica em andamento, garantindo que as opera√ß√µes de uma transa√ß√£o n√£o afetem outras.

- Integridade dos Dados: Garantir que os dados permanecem corretos e consistentes durante opera√ß√µes simult√¢neas.

## Processamento de Transa√ß√µes Multiusu√°rios
- O processamento de transa√ß√µes √© fundamental para sistemas onde v√°rias opera√ß√µes de leitura e escrita ocorrem ao mesmo tempo. As caracter√≠sticas do processamento de transa√ß√µes multiusu√°rios incluem:

- ACID Properties: As transa√ß√µes devem seguir as propriedades de Atomicidade, Consist√™ncia, Isolamento e Durabilidade para garantir que sejam executadas corretamente.

- Recupera√ß√£o de Falhas: Capacidade de restaurar o sistema a um estado consistente ap√≥s falhas, como quedas de energia ou erros de software.

- Gerenciamento de Transa√ß√µes: Ferramentas e t√©cnicas para iniciar, gerenciar e encerrar transa√ß√µes de forma eficiente e segura.

# Abordagem de SGBDs - atores, Workers, Vantagens e quando n√£o utilizar

## Atores
- administrador
	- Gerencia Recursos
	- Orquestra√ß√£o
	- Autoriza√ß√£o de acesso
- Designers
	- identificar dados e requisitos
	- Representa√ß√£o e Estrutura
	- Fase preliminar
- usu√°rios Finais
	- Acesso --> SQL Querys {consultas}
	- Categorizadas
## Workers
- background
	- Designer do sistema de SGBD
	- Implementa√ß√£o do sistema de SGBD
		- Implementa√ß√£o
	- Pessoal de opera√ß√£o e manuten√ß√£o
	- Desenvolvedores de Ferramentas

============ Modelagem ===========

# Modelagem: √â o processo de criar uma representa√ß√£o simplificada de um sistema ou fen√¥meno do mundo real, com o objetivo de entender, analisar e comunicar suas caracter√≠sticas e comportamentos. Na engenharia de software, a modelagem √© usada para descrever a estrutura, o comportamento e os dados dos sistemas de software antes de serem desenvolvidos.

# Entidade: Em modelagem, uma entidade representa um objeto ou conceito do mundo real que possui um significado espec√≠fico no contexto do sistema que est√° sendo modelado. Por exemplo, em um sistema de gerenciamento de uma biblioteca, as entidades podem incluir "Livro", "Usu√°rio" e "Empr√©stimo". Cada entidade possui atributos que descrevem suas caracter√≠sticas, como t√≠tulo e autor para a entidade "Livro".

# UML (Unified Modeling Language): √â uma linguagem de modelagem visual padronizada usada para especificar, visualizar, construir e documentar os artefatos de um sistema de software. A UML fornece um conjunto de diagramas que ajudam a representar diferentes aspectos do sistema, como:

- Diagramas de caso de uso (Use Case Diagrams)

- Diagramas de classes (Class Diagrams)

- Diagramas de sequ√™ncia (Sequence Diagrams)

- Diagramas de atividades (Activity Diagrams)

A UML √© amplamente utilizada na engenharia de software para auxiliar na comunica√ß√£o entre os membros da equipe de desenvolvimento e na documenta√ß√£o do sistema.

========= Arquitetura BDs =============
# Modelo
	- abstra√ß√£o = essencial
		- data model
- classifica√ß√£o	
	- Estrutura
	- Modelo de dados conceitual
		- vis√£o de alto n√≠vel
			- Entidade
			- Atributos
			- Relacionamentos
	- Modelo de Dados de Implementa√ß√£o
		- Representacional
			- Modelo de dados relacional
				- Constrains 
				- linguagens SQL
				- Opera√ß√£o
			- Modelos Hier√°rquicos
	- Modelo de dados F√≠sicos
		- especialista
# Esquemas, Inst√¢ncias e State BDs

- Schema
	- Descri√ß√£o
		- diagramas
- Inst√¢ncia
	- dados persistidos

- State BDs
	- update
	- insert
	- delete

# Three-Schema
- Views
- Cat√°logo
- Isolamento data/program

# Classifica√ß√£o de SGBDs
- Modelo de dados
	- SQL
	- NoSql
- N de usu√°rio
- N de sites
- Custo
- Tipo de caminho de acesso

===== Metodologia Modelagem de Dados =====

# mini-world Closed
- Retornar falso para dados n√£o existente no contexto do dbs

# √Ålgebra Relacional

- Linguagem formal para consulta/extra√ß√£o de dados
- O predicado √© a parte da ora√ß√£o que cont√©m o verbo e que traz informa√ß√µes sobre o sujeito.
	- Crit√©rio
		- where
		- having
- Processo do dbs
	- Projeto Conceitual
		- Projeto L√≥gico 
			- Projeto F√≠sico 
				- Valida√ß√£o
					- Produ√ß√£o								- Manuten√ß√£o
# Como Implementar um BD

- Entender o contexto e requisitos

- Perfil...

- Processo Evolutivo ou gradual
	- Implementa√ß√£o
	- Modelo
	- Arquitetura
	- Funcionalidades

# Projeto Conceitual

- Linguagens de modelagem de dados
	- Gr√°ficas
	- Textuais
- Coletas de Dados
- An√°lise

# Projeto L√≥gico
- Modelo Conceitual
	- Estrutura
		- Organiza√ß√£o dos dados

==== Project Logic x f√≠sico
O projeto l√≥gico se concentra na estrutura dos dados, enquanto o projeto f√≠sico considera a performance, armazenamento e seguran√ßa.


== Modelo ER: Tipos de Entidades, Chaves e Atributos ===

- Modelo Conceitual
	- Entidades
	- Atributos
	- Relacionamentos

- Diagrama ER
	- Raras Modifica√ß√µes
	- Facilidade de manipular
	- Esquema ER do dbs

# Entidades

- Componente B√°sico
- Exist√™ncia independente
- Atributos

# Atributos ER

- Caracter√≠sticas/Descri√ß√£o das Entidade

- Atributos Relacionados as inst√¢ncias
	- At√¥micos x Composto
		- At√¥micos simples √∫nica propriedade
		- Compostos por propriedades (concatena√ß√£o)
	- Atributos multivalorados
	- Armazenados e derivados
	- Atributos Nulos
	- Atributos Complexos

# Entidade Fraca

- Depend√™ncia: Elas dependem de uma entidade forte para sua identifica√ß√£o.

- Relacionamento Identificador: H√° um relacionamento entre a entidade fraca e a entidade forte, chamado de relacionamento identificador.

- Chave Parcial: A entidade fraca possui uma chave parcial que, combinada com a chave prim√°ria da entidade forte, forma a chave prim√°ria composta.

# Relacionamento Grau

- Relacionamento Bin√°rios
	- Aluno (entidade)
	- Curso (entidade)
	- Matricula (relacionamento)

- Relacionamento Tern√°rio
	- Paciente (entidade)
	- M√©dico (entidade)
	- Hospital (entidade)
	- Tratamento (relacionamento)

- N√∫mero de Entidades: Relacionamentos bin√°rios envolvem duas entidades, enquanto relacionamentos tern√°rios envolvem tr√™s entidades.

- Complexidade: Relacionamentos tern√°rios s√£o mais complexos e podem representar intera√ß√µes mais detalhadas entre entidades, comparado com relacionamentos bin√°rios.

# Constraints - Cardinalidade

- Cardinalidade
A cardinalidade, no contexto de rela√ß√µes, refere-se ao n√∫mero de tuplas (linhas) em uma rela√ß√£o. Em outras palavras, √© o total de registros presentes na tabela.

Exemplo: Se a tabela "Funcion√°rios" tiver 5 registros (linhas), sua cardinalidade ser√° 5.

Al√©m disso, a cardinalidade tamb√©m √© usada para descrever rela√ß√µes entre tabelas em um banco de dados, como:

1:1 (um para um): Cada linha de uma tabela est√° associada a uma √∫nica linha de outra tabela.

1:N (um para muitos): Uma linha de uma tabela pode estar associada a v√°rias linhas de outra tabela.

N:M (muitos para muitos): V√°rias linhas de uma tabela podem estar associadas a v√°rias linhas de outra tabela.

# Entidade Fraca

- Tipos de Entidades
	- Fracas
		- Dependem de outra
	- Relacionamento ID (interligadas)
	- Fortes
		- Owner Entity Type

# Nota√ß√µes DER

- Entidades: Classes/Objetos --> Ret√¢ngulo
- Relacionamentos: Agrega√ß√µes --> losango
- Atributos: Propriedades elementares --> eclipse
- Weak: Entidades, relacionamentos
- Chave Parcial: Linha pontilhada
- Chave principal: linha continua
- Depend√™ncia de exist√™ncia: ||
- Atributo derivado
- Atributo composto
- Participa√ß√£o total
- Cardinalidade 
- Constraint estrutural
# Relacionamento N-√°rio
- Tern√°rio,..., N-√°rio
- Perspectiva diferente do bin√°rio


==== Modelagem de Dados com EER ====
- Modelo ER 1970
- EER: Novos Conceitos Sem√¢nticos
- Desenvolvidos fora da √°rea de BDs
- Digrama ERR

# Modelo Enhanced ER
- Superclasses
- Heran√ßa
- Subclasses
	- Depende do contexto do BD
	- Objeto distinto no BD
	- Heran√ßa de Superclasse
- Generaliza√ß√£o e Especializa√ß√£o
- Categoria ou Union Type
- Heran√ßa: Atributo e relacionamento

# Heran√ßa

"Princ√≠pio pr√≥prio √° programa√ß√£o orientada a objetos (POO) que permite criar uma nova classe a partir de uma j√° existente."

- Reutiliza√ß√£o de c√≥digo
- Especializa√ß√£o de classes
- Agregar atributos e m√©todos

# Especializa√ß√£o e Generaliza√ß√£o

- Generaliza√ß√£o: Combina m√∫ltiplas entidades espec√≠ficas em uma entidade gen√©rica (movimento de "baixo para cima").
- Exemplo: Entidades Carro e Caminh√£o podem ser generalizadas para Ve√≠culo.

- Especializa√ß√£o: Divide uma entidade gen√©rica em entidades mais espec√≠ficas (movimento de "cima para baixo").
- Exemplo: Ve√≠culo pode ser especializado em Carro e Caminh√£o.

# [1:1]
- inst√¢ncias das superclasse e subclasses
- Mesma representa√ß√£o de mundo real
- Papel especializado

# Diferen√ßa Fundamental:
A generaliza√ß√£o foca em encontrar semelhan√ßas e agrupar o que √© comum, enquanto a especializa√ß√£o foca em identificar diferen√ßas e detalhar o que √© √∫nico.

# Constraints - Modelo EER 
- Predicated-defined (condi√ß√£o)
	- Defini√ß√£o: Aqui, a divis√£o de um supertipo em subtipos 	√© feita com base em condi√ß√µes l√≥gicas ou predicados.
- Attribute-defined Specialization
	- Defini√ß√£o: A especializa√ß√£o ou generaliza√ß√£o √© guiada 	por valores espec√≠ficos de um atributo no supertipo.
- User-defined
	- Defini√ß√£o: Neste caso, n√£o h√° predicados ou atributos 	claramente definidos. A categoriza√ß√£o √© baseada na 	decis√£o manual do usu√°rio.

# Hier√°rquica & Rede de Especializa√ß√£o
- Hierarquia de especializa√ß√£o
- Rede de especializa√ß√£o

# Estrutura no Modelo

- Categoriza√ß√£o: N√£o altera a estrutura das entidades. Cada uma mant√©m seus atributos e relacionamentos. A categoriza√ß√£o √© mais como "etiquetas" ou identificadores.
- Exemplo: Na categoriza√ß√£o, voc√™ identifica Cliente VIP sem mudar a estrutura da tabela de Clientes.

- Union Types: Requer a cria√ß√£o de uma nova entidade que abstrai ou agrega entidades distintas. Isso pode alterar a forma como os relacionamentos e atributos s√£o modelados.
- Exemplo: Ao criar um Union Type como Usu√°rioBiblioteca, atributos ou relacionamentos comuns (como Data de Empr√©stimo) s√£o migrados para o tipo unificado.

# Terminologias

- Knowledge representation (KR)

- Ontologia

# Conceitos Modelo Relacional
- Modelo Relacional
	- Cole√ß√£o de Rela√ß√£o
		- Classes
		- Objetos
- Tabelas x Arquivos
- Entidade
- tabela --> Rela√ß√£o
- Tupla --> linha || inst√¢ncia || registro
- Atributo --> propriedade/Coluna da rela√ß√£o

# O que √© L√≥gica de Predicado?
A l√≥gica de predicado √© um ramo da l√≥gica matem√°tica que estuda proposi√ß√µes com vari√°veis e quantificadores, como "para todo" (‚àÄ) e "existe" (‚àÉ). Diferente da l√≥gica proposicional (que usa apenas proposi√ß√µes simples), a l√≥gica de predicado permite descrever rela√ß√µes entre objetos e suas propriedades de forma mais detalhada.
Por exemplo:
	- Proposi√ß√£o: "Maria √© uma estudante."
	
	- L√≥gica de Predicado: Estudante(Maria), onde "Estudante" √© um predicado que define uma propriedade da vari√°vel "Maria".
	
- Consultas SQL: A l√≥gica de predicado influencia a forma como as consultas s√£o formuladas. Um comando SQL, como SELECT, √© semelhante √† aplica√ß√£o de predicados para filtrar ou projetar os dados.


# Dom√≠nio
O dom√≠nio refere-se ao conjunto de valores poss√≠veis que um atributo pode assumir. √â como uma "regra" que define os valores v√°lidos para determinada coluna.

Exemplo: Se o atributo "Idade" tiver um dom√≠nio definido como n√∫meros inteiros entre 18 e 65, isso significa que somente valores dentro desse intervalo ser√£o aceitos para essa coluna.

O dom√≠nio garante que os dados armazenados sejam v√°lidos e consistentes com as restri√ß√µes aplicadas.

# Constraints Modelo Relacional

- Integridade dos Dados: Garantem que os dados sejam v√°lidos e consistentes com as regras do sistema.

- Preven√ß√£o de Erros: Evitam a entrada de dados inv√°lidos.

- Automatiza√ß√£o de Regras de Neg√≥cio: Muitas regras podem ser implementadas diretamente no design do banco de dados.

- DDL --> Data Definition Language --> Create, Drop, Insert, Rename
- DML --> Data Manipulation Language --> Insert, Update, Delete, Merge
- DCL --> Data Control Language --> Grant, Revoke
- DQL - Data Query Language --> Select

- Integridade Referencial: √â uma regra que mant√©m os relacionamentos entre tabelas consistentes, garantindo que n√£o haja refer√™ncias a dados inexistentes em tabelas relacionadas.

- Chave Estrangeira (Foreign Key): √â um campo em uma tabela que cria o v√≠nculo com a chave prim√°ria de outra tabela, assegurando a integridade referencial.

# Relacionamentos 1:1

geralmente existem duas op√ß√µes para o mapeamento relacional:
1. Unir as tabelas: Incorporar os atributos de uma entidade na tabela da outra.
2. Usar chaves estrangeiras: Cada entidade mant√©m sua tabela, e o relacionamento √© representado por uma chave estrangeira.
	1. Use a primeira abordagem quando o relacionamento √© altamente dependente e quase insepar√°vel.

	2.	A segunda abordagem √© preferida quando as entidades t√™m identidades pr√≥prias e podem existir separadamente.

# Um relacionamento bin√°rio 1:N 

(um para muitos) ocorre quando uma entidade A se associa a v√°rias entidades B, mas cada entidade B est√° associada a apenas uma entidade A.

1. Identificar as Entidades e o Relacionamento:
Exemplo: Entidade Cliente (1) e Pedido (N).

Um cliente pode fazer v√°rios pedidos, mas cada pedido est√° associado a um √∫nico cliente.

2. Definir o Relacionamento:
A tabela que representa o lado "muitos" (Pedidos) conter√° uma chave estrangeira que referencia a tabela do lado "um" (Clientes).

# Relacionamento N:M

Mapeamento de relacionamentos bin√°rios N:M (muitos para muitos) √© um conceito comum em modelagem de banco de dados relacional e an√°lise de sistemas. Ele representa uma associa√ß√£o onde m√∫ltiplas entidades de um lado podem estar relacionadas a m√∫ltiplas entidades do outro lado.

Esse modelo permite rastrear facilmente as associa√ß√µes entre as duas entidades e facilita a consulta ou manipula√ß√£o de dados. Posso detalhar mais, se precisar de algo espec√≠fico! üòä

=========== SQL ===========
- DDL --> Data Definition Language
	- Create | Drop | Alter
	- Insert | Update | Delete
	- Rename | Truncate | Merge
- User
- Schema
- Statementss
- INDEXING

# DDL (Data Definition Language)
Prop√≥sito: Definir e modificar a estrutura do banco de dados.

Comandos comuns:

CREATE: Cria novos objetos no banco de dados, como tabelas e √≠ndices.

ALTER: Modifica a estrutura de objetos existentes.

DROP: Remove objetos do banco.

TRUNCATE: Remove todos os registros de uma tabela, mantendo sua estrutura.

Foco: Gerencia a defini√ß√£o e organiza√ß√£o do banco de dados.

Reversibilidade: As altera√ß√µes geralmente n√£o podem ser revertidas (exemplo: ao usar DROP).

# DML (Data Manipulation Language)
Prop√≥sito: Manipular dados armazenados nas tabelas.

Comandos comuns:

SELECT: Recupera dados.

INSERT: Insere novos registros.

UPDATE: Atualiza registros existentes.

DELETE: Remove registros.

Foco: Lida com os dados propriamente ditos, sem modificar a estrutura das tabelas.

Reversibilidade: As altera√ß√µes realizadas podem ser desfeitas dentro de uma transa√ß√£o (usando ROLLBACK).

# DCL (Data Control Language)
Prop√≥sito: Gerenciar permiss√µes e seguran√ßa no banco de dados.

Comandos principais:

GRANT: Concede permiss√µes a usu√°rios ou pap√©is para acessar e realizar a√ß√µes no banco de dados.

Exemplo: GRANT SELECT, INSERT ON clientes TO usuarioX;

REVOKE: Revoga permiss√µes previamente concedidas.

Exemplo: REVOKE INSERT ON clientes FROM usuarioX;

Foco: Controlar quem pode acessar ou modificar os dados e as estruturas do banco.

# DQL (Data Query Language)
Prop√≥sito: Consultar dados do banco de dados.

Comando principal:

SELECT: √â a base do DQL e permite buscar dados de uma ou mais tabelas.

Exemplo: SELECT nome, email FROM clientes WHERE cidade = 'Rio de Janeiro';

Foco: Extrair e visualizar informa√ß√µes armazenadas no banco de dados.

# Constraints

PRIMARY KEY: Garante que cada registro de uma tabela seja √∫nico.

FOREIGN KEY: Estabelece uma rela√ß√£o entre duas tabelas, ligando uma chave de uma tabela √† chave prim√°ria de outra:

NOT NULL: Impede que uma coluna tenha valores nulos:

UNIQUE: Garante que todos os valores em uma coluna sejam √∫nicos:

CHECK: Define uma condi√ß√£o para os valores de uma coluna:

DEFAULT: Especifica um valor padr√£o para uma coluna, caso n√£o seja fornecido nenhum valor:

# Teoria por Tr√°s dos Alias
	Um alias √© simplesmente um nome alternativo, tempor√°rio e amig√°vel atribu√≠do a colunas ou tabelas dentro de uma consulta SQL. Ele serve para melhorar a legibilidade do c√≥digo ou facilitar a refer√™ncia a elementos complexos (como colunas calculadas ou subconsultas). Um alias n√£o altera os nomes reais no banco de dados, apenas os renomeia durante a execu√ß√£o da consulta.

Express√µes em SQL
	As express√µes s√£o usadas para realizar opera√ß√µes ou c√°lculos no SELECT. Elas podem incluir operadores aritm√©ticos, fun√ß√µes, concatena√ß√µes de strings e muito mais. Exemplos de express√µes comuns incluem:

	SELECT pre√ßo * quantidade AS total FROM vendas;

	SELECT nome || ' ' || sobrenome AS nome_completo FROM clientes;
	No exemplo acima, usamos || (em alguns bancos) para concatenar nome e sobrenome.

# LIKE
	O operador LIKE √© usado em consultas SQL para buscar padr√µes espec√≠ficos em colunas de texto. Ele funciona com curingas para tornar as buscas flex√≠veis:
	%: Representa zero ou mais caracteres.
¬¥¬¥
	SELECT * FROM clientes
	WHERE nome LIKE 'Jo%';
¬¥¬¥
	Isso vai retornar todos os clientes cujos nomes come√ßam com "Jo", como "Joana" ou "Jos√©".

# Outro exemplo:
	_: Representa um √∫nico caractere.
``
	SELECT * FROM produtos
	WHERE descricao LIKE '_ola';
``
	Isso busca algo como "bola", "cola", etc., j√° que o _ exige exatamente um caractere antes de "ola".

# BETWEEN
	O operador BETWEEN √© usado para buscar valores dentro de um intervalo. Ele funciona para tipos como n√∫meros, datas e at√© texto (seguindo a ordem alfab√©tica).
	- Exemplo com n√∫meros:
``
	SELECT * FROM vendas
	WHERE preco BETWEEN 50 AND 100;
``
	Isso retorna todas as vendas com pre√ßos entre 50 e 100, incluindo os limites.

# Exemplo com datas:
``
	SELECT * FROM pedidos
	WHERE data BETWEEN '2025-01-01' AND '2025-03-31';
``
	Aqui, voc√™ vai obter todos os pedidos feitos nesse trimestre.

# UNION
	O operador UNION combina os resultados de duas ou mais consultas, eliminando duplicatas por padr√£o. Os conjuntos devem ter o mesmo n√∫mero e tipo de colunas para funcionar.
``
	SELECT nome, email FROM clientes_brasil
	UNION
	SELECT nome, email FROM clientes_mexico;
``
	Esse comando retorna uma lista unificada de clientes do Brasil e do M√©xico, sem duplicatas.

# INTERSECT
	O operador INTERSECT retorna apenas as linhas que est√£o presentes em ambas as consultas.
``
	SELECT nome FROM clientes_brasil
	INTERSECT
	SELECT nome FROM clientes_mexico;
``
	Isso mostrar√° apenas os clientes que est√£o tanto na base do Brasil quanto na do M√©xico.

# EXCEPT
	O operador EXCEPT retorna as linhas que est√£o na primeira consulta, mas n√£o est√£o na segunda.
``
	SELECT nome FROM clientes_brasil
	EXCEPT
	SELECT nome FROM clientes_mexico;
``
	Isso listar√° os clientes que est√£o apenas no Brasil e n√£o no M√©xico.

Considera√ß√µes:
	Essas opera√ß√µes seguem a estrutura de colunas compat√≠veis (mesmo n√∫mero e tipo de colunas).

	A ordem das colunas e os nomes das tabelas podem importar para interpreta√ß√µes mais complexas.

	O suporte a INTERSECT e EXCEPT pode variar entre bancos de dados (alguns, como o MySQL, n√£o possuem nativamente, mas h√° alternativas).

Uma Nested Query (ou consulta aninhada)
	em SQL √© uma consulta dentro de outra consulta. A consulta interna (ou subconsulta) √© executada primeiro e o resultado √© usado pela consulta externa. Essas subconsultas s√£o geralmente usadas em instru√ß√µes SELECT, INSERT, UPDATE ou DELETE para realizar opera√ß√µes mais complexas ou filtragens.

A keyword IN em SQL 
	√© usada para especificar m√∫ltiplos valores em uma cl√°usula WHERE. √â uma maneira pr√°tica de verificar se um valor est√° dentro de uma lista de valores fornecidos, em vez de usar v√°rias condi√ß√µes combinadas com OR. Isso simplifica e torna as consultas mais leg√≠veis.

=== Cl√°usulas
	EXISTS: TRUE se o resultado da consulta aninhada contiver pelo menos uma tupla;

	NOT EXISTS: TRUE se o resultado da consulta aninhada n√£o contiver tuplas;

	UNIQUE: Retornar TRUE se √© √∫nico;

# SQL ORDER  BY
	A cl√°usula SQL ORDER BY √© usada para organizar os resultados de uma consulta em ordem ascendente (ASC) ou descendente (DESC), com base em uma ou mais colunas. Por padr√£o, a ordem √© crescente.

# Agrupamento de Registros;
	Agregar | Aglutinar | agrupar
	O GROUP BY √© uma cl√°usula no SQL usada para agrupar linhas que t√™m valores semelhantes em colunas espec√≠ficas. Ele √© muito √∫til para agregar dados e gerar resumos usando fun√ß√µes como COUNT(), SUM(), AVG(), MAX() e MIN().

==== Join ==== 
O que √© JOIN?
	O JOIN √© usado para combinar linhas de duas ou mais tabelas com base em uma condi√ß√£o l√≥gica.
	Geralmente, relacionamos tabelas usando uma chave prim√°ria de uma tabela e uma chave estrangeira de outra.

Tipos de JOIN:
	INNER JOIN (ou simplesmente JOIN): Retorna apenas as linhas que t√™m correspond√™ncia em ambas as tabelas.

	LEFT JOIN (ou LEFT OUTER JOIN): Retorna todas as linhas da tabela √† esquerda (A), mesmo que n√£o haja correspond√™ncia na tabela √† direita (B). Linhas sem correspond√™ncia em B ter√£o valores NULL.

	RIGHT JOIN (ou RIGHT OUTER JOIN): Retorna todas as linhas da tabela √† direita (B), mesmo que n√£o haja correspond√™ncia na tabela √† esquerda (A). Linhas sem correspond√™ncia em A ter√£o valores NULL.

	FULL JOIN (ou FULL OUTER JOIN): Retorna todas as linhas de ambas as tabelas. Linhas sem correspond√™ncia em uma das tabelas ter√£o valores NULL.

	CROSS JOIN: Retorna o produto cartesiano de ambas as tabelas (todas as combina√ß√µes poss√≠veis de linhas entre as tabelas).

	SELF JOIN: √â um JOIN de uma tabela com ela mesma. √ötil para comparar linhas dentro da mesma tabela.

# CASE WHEN THEN ELSE END
	A declara√ß√£o CASE √© usada para realizar condi√ß√µes dentro de uma consulta SQL e retornar valores baseados nessas condi√ß√µes. Ela √© parecida com um "if-else" em programa√ß√£o.
	Dicas:
	Voc√™ pode usar o CASE em praticamente qualquer lugar: em SELECT, WHERE, UPDATE, ORDER BY ou at√© mesmo HAVING.

	√â uma √≥tima maneira de criar categorias e personalizar os resultados dsa sua consulta.

# O que s√£o views?
	Uma view (ou vis√£o) √© essencialmente uma consulta armazenada no banco de dados, que pode ser tratada como uma tabela virtual. Essa tabela virtual n√£o armazena dados diretamente; em vez disso, ela exibe os dados provenientes de outras tabelas, baseando-se na consulta que a define. Pense nisso como uma "janela" para os dados, que facilita visualiza√ß√µes personalizadas e organizadas.

# Por que utilizar views?
	Aqui est√£o alguns motivos principais para utilizar views:
	
	1. Simplicidade: Elas podem simplificar consultas complexas. Por exemplo, se voc√™ tem uma consulta complicada que √© usada frequentemente, pode transform√°-la em uma view.
	
	2. Seguran√ßa: √â poss√≠vel restringir o acesso a determinados dados. Por exemplo, voc√™ pode criar uma view que s√≥ mostre certas colunas de uma tabela, ocultando outras.

	3. Manuten√ß√£o de dados: Ajuda a criar camadas de abstra√ß√£o. Se a estrutura das tabelas subjacentes mudar, basta ajustar a view, sem a necessidade de alterar as consultas em v√°rias partes do aplicativo.

	4. Reutiliza√ß√£o: Podem ser reutilizadas em diferentes partes do sistema, reduzindo redund√¢ncias no c√≥digo SQL.

# Restri√ß√µes e limita√ß√µes de views
	Apesar dos benef√≠cios, as views t√™m algumas restri√ß√µes e limita√ß√µes:

	1. Somente leitura: Algumas views podem ser somente leitura, especialmente se contiverem opera√ß√µes complexas como JOIN, agrega√ß√µes (SUM, AVG), ou DISTINCT.

	2. Performance: Como s√£o baseadas em consultas, o uso excessivo de views pode impactar o desempenho, especialmente em bancos com grande volume de dados.

	3. Atualiza√ß√µes: Nem todas as views podem ser atualizadas diretamente. Quando poss√≠vel, isso depende de como a view foi definida
	
	4. Depend√™ncia: Altera√ß√µes na estrutura das tabelas subjacentes podem exigir ajustes nas views  

# Atomicidade - ACID
	A atomicidade significa que uma transa√ß√£o no banco de dados deve ser tratada como uma unidade √∫nica e indivis√≠vel. Ou seja, ou todas as opera√ß√µes dentro de uma transa√ß√£o s√£o conclu√≠das com sucesso, ou nenhuma delas √© aplicada. Isso evita que dados sejam deixados em um estado inconsistente.

	Por exemplo, imagine que voc√™ est√° transferindo dinheiro de uma conta para outra:
	1. Debitar da Conta A.
	2. Creditar na Conta B
	
	Se ocorrer um erro depois de debitar a Conta A, mas antes de creditar na Conta B, a atomicidade garante que a transa√ß√£o ser√° revertida, mantendo as contas como estavam antes da opera√ß

# SQL Dinamico
	SQL din√¢mico √© uma t√©cnica utilizada para construir instru√ß√µes SQL de forma flex√≠vel e adapt√°vel. Ou seja, em vez de escrever consultas SQL est√°ticas, podemos criar scripts que geram essas consultas dinamicamente com base em vari√°veis ou condi√ß√µes espec√≠ficas. Isso √© especialmente √∫til quando precisamos adaptar a consulta de acordo com os dados fornecidos pelo usu√°rio ou requisitos espec√≠ficos do programa.
	
	# Por que usar SQL din√¢mico?
		Adaptabilidade: Permite construir consultas em tempo de execu√ß√£o.
		Flexibilidade: Ideal para cen√°rios onde n√£o sabemos antecipadamente a estrutura exata da consulta.
		Automatiza√ß√£o: Reduz a necessidade de criar m√∫ltiplas consultas est√°ticas para diferentes cen√°rios.
	
	Como funciona na pr√°tica? Vamos ao exemplo! Imagine que queremos consultar uma tabela chamada "Produtos" e filtrar os resultados com base em crit√©rios que s√≥ descobriremos na execu√ß√£o. O SQL din√¢mico pode ser criado assim:
	DECLARE @sql NVARCHAR(MAX);
	DECLARE @categoria NVARCHAR(50);

	SET @categoria = 'Eletr√¥nicos';

	SET @sql = 'SELECT * FROM Produtos WHERE Categoria = ''' + @categoria + '''';

	EXEC sp_executesql @sql;

	A vari√°vel @categoria armazena o filtro desejado
	A instru√ß√£o SQL √© concatenada usando a vari√°vel, criando uma consulta personalizada.
	sp_executesql executa o SQL din√¢mico gerado.

	# Cuidados ao usar SQL din√¢mico:
		Seguran√ßa: Evite vulnerabilidades de SQL Injection. Sempre valide os dados inseridos pelo usu√°rio
		
		Desempenho: Pode ser menos eficiente do que consultas est√°ticas. Use com modera√ß√£o.

		Legibilidade: Pode dificultar a manuten√ß√£o do c√≥digo, ent√£o documente bem.

# O que √© uma stored procedure?
	Uma stored procedure (ou "procedimento armazenado") √© basicamente um conjunto de comandos SQL que √© salvo no banco de dados e pode ser reutilizado sempre que necess√°rio. Pense nela como uma fun√ß√£o no mundo da programa√ß√£o: voc√™ escreve o c√≥digo uma vez, armazena no banco e pode cham√°-lo sempre que precisar executar aquela l√≥gica.
	
	# Por que usar stored procedures?
		- Reutiliza√ß√£o: Pode ser chamada v√°rias vezes sem precisar escrever o mesmo c√≥digo repetidamente.
		- Efici√™ncia: Reduz o tr√°fego entre a aplica√ß√£o e o banco de dados, j√° que o c√≥digo √© executado no servidor de banco.
		- Seguran√ßa: Pode controlar o acesso, permitindo que usu√°rios executem a procedure sem precisar visualizar diretamente os dados do banco
		- Manuten√ß√£o: Facilita as altera√ß√µes, pois voc√™ edita o c√≥digo em um √∫nico lugar.
	
	# Exemplo de stored procedure:
		Vamos criar uma procedure que retorna os produtos de uma determinada categoria:
		CREATE PROCEDURE GetProdutosPorCategoria
    @Categoria NVARCHAR(50) -- variable
		AS
		BEGIN -- inicio
				SELECT * FROM Produtos
				WHERE Categoria = @Categoria;
		END; -- fim
	Como usar essa stored procedure?
	Depois de criar a procedure, podemos execut√°-la assim:
	EXEC GetProdutosPorCategoria @Categoria = 'Eletr√¥nicos';
	
	Vantagens adicionais:
		Ajuda a organizar melhor o c√≥digo SQL.
		√â √≥tima para cen√°rios onde h√° muita l√≥gica complexa.
	
	Cuidado:
		Como em qualquer outro recurso, use com sabedoria para evitar consultas que possam afetar o desempenho do banco.

# O Que √© Condition Handling?
	Quando algo d√° errado, como uma divis√£o por zero ou uma viola√ß√£o de restri√ß√£o, o MySQL gera uma condi√ß√£o. Para lidar com essas condi√ß√µes, usamos handlers dentro de Stored Procedures ou Triggers. Um Handler informa ao SQL como reagir a um erro ou aviso espec√≠fico
	
	# Estrutura B√°sica de um Handler
		Um handler √© configurado dentro de uma procedure com a seguinte estrutura:
		DECLARE tipo_do_handler HANDLER FOR condi√ß√£o_espec√≠fica 
    a√ß√£o_a_ser_executada;

		tipo_do_handler: Define como o handler funciona
			CONTINUE: Ignora o erro ou condi√ß√£o e prossegue para a pr√≥xima instru√ß√£o.
			EXIT Sai imediatamente da procedure ou bloco.
		
		condi√ß√£o_espec√≠fica: Define o tipo de condi√ß√£o que o handler captura, como:
			SQLEXCEPTION: Captura qualquer erro SQL.
			SQLWARNING: Captura alertas.
			NOT FOUND: Captura situa√ß√µes onde um resultado esperado n√£o foi encontrado.
	
	# Exemplo 1: Tratando SQLEXCEPTION com CONTINUE
		Imagine que queremos capturar erros e continuar a execu√ß√£o:
		DELIMITER $$
			CREATE PROCEDURE exemplo_handler()
			BEGIN
					DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
							SET @erro = 'Ocorreu um erro, mas estamos continuando!';
					
					-- Tentativa de divis√£o por zero (gera erro)
					SET @resultado = 10 / 0;

					-- O pr√≥ximo c√≥digo ser√° executado mesmo ap√≥s o erro
					SET @mensagem = 'Execu√ß√£o continuada ap√≥s o erro!';
					SELECT @mensagem;
			END $$
		DELIMITER ;

	# Exemplo 2: Tratando NOT FOUND com EXIT
		Este exemplo lida com situa√ß√µes em que nenhum dado √© encontrado, e encerra o bloco.
		DELIMITER $$
			CREATE PROCEDURE exemplo_not_found()
			BEGIN
					DECLARE EXIT HANDLER FOR NOT FOUND
							SET @mensagem = 'Nenhum dado encontrado!';
					
					-- Tentativa de buscar um dado inexistente
					SELECT nome INTO @resultado FROM usuarios WHERE id = -1;
					
					-- Se nenhum dado for encontrado, o handler ser√° acionado
					SELECT @mensagem;
			END $$
		DELIMITER ;
	Resultado: A execu√ß√£o termina com uma mensagem caso nenhum dado seja encontrado.

	# Por que Usar Condition Handling?
		- Robustez: Garante que o c√≥digo lide com problemas sem falhas graves.
		- Personaliza√ß√£o: Permite mostrar mensagens mais informativas.
		- Controle: D√° flexibilidade para decidir como proceder em diferentes situa√ß√µes.
	
	# 1. Objetivo e Uso
		Procedures (Procedimentos): S√£o usadas principalmente para executar a√ß√µes complexas e processos. Podem incluir m√∫ltiplas opera√ß√µes como inserir, atualizar ou consultar dados.
			Exemplo: Executar v√°rios c√°lculos, modificar tabelas ou interagir com m√∫ltiplos registros.
			Normalmente chamadas diretamente com CALL.
		
		Functions (Fun√ß√µes): S√£o usadas para retornar um √∫nico valor baseado em um c√°lculo ou opera√ß√£o. Geralmente utilizadas dentro de queries SQL:
			Exemplo: Retornar o total de vendas ou calcular impostos.
			Chamadas diretamente em express√µes SQL como SELECT minha_funcao().
	
	# 2. Forma de Chamada
		CALL minha_procedure(parametros);
		SELECT minha_funcao(parametros);
	
	# 3. Sa√≠da
		Procedures: Podem ter m√∫ltiplas sa√≠das, seja por meio de vari√°veis ou manipula√ß√£o de tabelas. Elas n√£o s√£o usadas diretamente dentro de queries.

		Functions: Devem retornar exatamente um valor (como n√∫meros, textos ou resultados calculados), sendo frequentemente usadas dentro de .
	
	# 4. Utiliza√ß√£o em Queries
		Procedures: N√£o podem ser usadas diretamente em queries SQL, apenas chamadas com CALL.
		
		Functions: Podem ser integradas em queries SQL.
			Exemplo:
				SELECT minha_funcao(parametros) AS resultado;
	
	# 5. Manipula√ß√£o de Dados
		Procedures: Podem modificar dados, incluindo inser√ß√µes, atualiza√ß√µes ou exclus√µes em tabelas.
		
		Functions: N√£o devem modificar dados diretamente; s√£o limitadas ao c√°lculo e retorno de valores.