SQL

- Modelagem de dados
- Construção de Banco de Dados
- Interpretação e Extração de Dados
- Desempenho
- Manutenção dos Métodos e procedures
- Equipe do DBA

=== Fundamentos do Banco de dados.
- Introduction a banco de dados.
- Sistemas de Gerenciamento de banco de dados.
- Modelagem de Dados para banco de dados.
- Arquitetura de banco de dados.

= Banco de dados
- Negócios
- E-commerce
- Medicina
- Engenharia
- Social Media
- Database --> Conjunto de dados.
`
Um banco de dados é um sistema utilizado para armazenar, organizar e gerenciar grandes volumes de dados de maneira eficiente e estruturada..
`
- Contexto --> representação do mundo real
- Coerência;
- Propósito

================ SGBDs ======================
# SGBDs --> Sistemas de Gerenciamento de Banco de dado.

- Recuperação de Dados: Gerencia a forma como os dados são armazenados fisicamente e fornece mecanismos para recuperá-los rapidamente.

- Controle de Acesso: Garante que apenas usuários autorizados possam acessar e modificar os dados, proporcionando segurança e integridade.

- Integridade de Dados: Assegura que os dados armazenados estão corretos e consistentes.

- Suporte a Transações: Garante que operações de banco de dados, chamadas de transações, sejam realizadas completamente ou não sejam realizadas de forma alguma, mantendo a consistência do banco de dados.

- Administração de Dados: Fornece ferramentas para monitorar e otimizar o desempenho do banco de dados.

# Modelo Relacional
- Tabelas: Estruturas que armazenam dados em linhas e colunas.

- Chaves Primárias: Campos que identificam unicamente cada registro em uma tabela.

- Chaves Estrangeiras: Campos que criam relacionamentos entre tabelas, ligando um campo de uma tabela a um campo correspondente de outra tabela.

- Normalização: Processo de organizar dados para reduzir a redundância e melhorar a integridade dos dados.

- SQL (Structured Query Language): Linguagem padrão usada para gerenciar e consultar bancos de dados relacionais.

## SGBDs Mais utilizado no Mercado.
- Oracle
- MySQL
- SQLServer
- PostgreSQL
- MongoDB 
- Redis

## SGBDs Natureza auto-descritiva
- Descrição da estrutura e constrains
- DB schema 

## SGBDs Isolamento e abstração.
- Abstração --> independência do programa e dados
- Transparência  

## Múltiplas Visões dos dados.
` Em um contexto de SGBDs relacionais, múltiplas visões dos dados referem-se à capacidade de visualizar dados de diferentes maneiras para atender a necessidades específicas. Isso pode ser realizado através de`

- Views (Visões): Consultas SQL armazenadas que apresentam dados específicos de uma ou mais tabelas sem alterar os dados subjacentes.

- Índices: Estruturas que melhoram a eficiência das consultas e permitem acesso rápido a registros.

- Consultas Personalizadas: SQL permite a criação de consultas personalizadas para extrair e visualizar dados conforme necessário.

- Relatórios Dinâmicos: Ferramentas que geram relatórios com base em critérios definidos pelo usuário.


## Compartilhamento de Dados
- O compartilhamento de dados é uma das principais funções dos SGBDs. Ele permite que diferentes usuários e aplicações acessem os mesmos dados sem conflitos. Algumas das características importantes do compartilhamento de dados incluem:

- Controle de Concurrency: Técnicas como bloqueios e controle de versões são usadas para garantir que múltiplas transações possam ocorrer simultaneamente sem interferências indesejadas.

- Isolamento: Cada transação opera como se fosse a única em andamento, garantindo que as operações de uma transação não afetem outras.

- Integridade dos Dados: Garantir que os dados permanecem corretos e consistentes durante operações simultâneas.

## Processamento de Transações Multiusuários
- O processamento de transações é fundamental para sistemas onde várias operações de leitura e escrita ocorrem ao mesmo tempo. As características do processamento de transações multiusuários incluem:

- ACID Properties: As transações devem seguir as propriedades de Atomicidade, Consistência, Isolamento e Durabilidade para garantir que sejam executadas corretamente.

- Recuperação de Falhas: Capacidade de restaurar o sistema a um estado consistente após falhas, como quedas de energia ou erros de software.

- Gerenciamento de Transações: Ferramentas e técnicas para iniciar, gerenciar e encerrar transações de forma eficiente e segura.

# Abordagem de SGBDs - atores, Workers, Vantagens e quando não utilizar

## Atores
- administrador
	- Gerencia Recursos
	- Orquestração
	- Autorização de acesso
- Designers
	- identificar dados e requisitos
	- Representação e Estrutura
	- Fase preliminar
- usuários Finais
	- Acesso --> SQL Querys {consultas}
	- Categorizadas
## Workers
- background
	- Designer do sistema de SGBD
	- Implementação do sistema de SGBD
		- Implementação
	- Pessoal de operação e manutenção
	- Desenvolvedores de Ferramentas

============ Modelagem ===========

# Modelagem: É o processo de criar uma representação simplificada de um sistema ou fenômeno do mundo real, com o objetivo de entender, analisar e comunicar suas características e comportamentos. Na engenharia de software, a modelagem é usada para descrever a estrutura, o comportamento e os dados dos sistemas de software antes de serem desenvolvidos.

# Entidade: Em modelagem, uma entidade representa um objeto ou conceito do mundo real que possui um significado específico no contexto do sistema que está sendo modelado. Por exemplo, em um sistema de gerenciamento de uma biblioteca, as entidades podem incluir "Livro", "Usuário" e "Empréstimo". Cada entidade possui atributos que descrevem suas características, como título e autor para a entidade "Livro".

# UML (Unified Modeling Language): É uma linguagem de modelagem visual padronizada usada para especificar, visualizar, construir e documentar os artefatos de um sistema de software. A UML fornece um conjunto de diagramas que ajudam a representar diferentes aspectos do sistema, como:

- Diagramas de caso de uso (Use Case Diagrams)

- Diagramas de classes (Class Diagrams)

- Diagramas de sequência (Sequence Diagrams)

- Diagramas de atividades (Activity Diagrams)

A UML é amplamente utilizada na engenharia de software para auxiliar na comunicação entre os membros da equipe de desenvolvimento e na documentação do sistema.

========= Arquitetura BDs =============
# Modelo
	- abstração = essencial
		- data model
- classificação	
	- Estrutura
	- Modelo de dados conceitual
		- visão de alto nível
			- Entidade
			- Atributos
			- Relacionamentos
	- Modelo de Dados de Implementação
		- Representacional
			- Modelo de dados relacional
				- Constrains 
				- linguagens SQL
				- Operação
			- Modelos Hierárquicos
	- Modelo de dados Físicos
		- especialista
# Esquemas, Instâncias e State BDs

- Schema
	- Descrição
		- diagramas
- Instância
	- dados persistidos

- State BDs
	- update
	- insert
	- delete

# Three-Schema
- Views
- Catálogo
- Isolamento data/program

# Classificação de SGBDs
- Modelo de dados
	- SQL
	- NoSql
- N de usuário
- N de sites
- Custo
- Tipo de caminho de acesso

===== Metodologia Modelagem de Dados =====

# mini-world Closed
- Retornar falso para dados não existente no contexto do dbs

# Álgebra Relacional

- Linguagem formal para consulta/extração de dados
- O predicado é a parte da oração que contém o verbo e que traz informações sobre o sujeito.
	- Critério
		- where
		- having
- Processo do dbs
	- Projeto Conceitual
		- Projeto Lógico 
			- Projeto Físico 
				- Validação
					- Produção								- Manutenção
# Como Implementar um BD

- Entender o contexto e requisitos

- Perfil...

- Processo Evolutivo ou gradual
	- Implementação
	- Modelo
	- Arquitetura
	- Funcionalidades

# Projeto Conceitual

- Linguagens de modelagem de dados
	- Gráficas
	- Textuais
- Coletas de Dados
- Análise

# Projeto Lógico
- Modelo Conceitual
	- Estrutura
		- Organização dos dados

==== Project Logic x físico
O projeto lógico se concentra na estrutura dos dados, enquanto o projeto físico considera a performance, armazenamento e segurança.


== Modelo ER: Tipos de Entidades, Chaves e Atributos ===

- Modelo Conceitual
	- Entidades
	- Atributos
	- Relacionamentos

- Diagrama ER
	- Raras Modificações
	- Facilidade de manipular
	- Esquema ER do dbs

# Entidades

- Componente Básico
- Existência independente
- Atributos

# Atributos ER

- Características/Descrição das Entidade

- Atributos Relacionados as instâncias
	- Atômicos x Composto
		- Atômicos simples única propriedade
		- Compostos por propriedades (concatenação)
	- Atributos multivalorados
	- Armazenados e derivados
	- Atributos Nulos
	- Atributos Complexos

# Entidade Fraca

- Dependência: Elas dependem de uma entidade forte para sua identificação.

- Relacionamento Identificador: Há um relacionamento entre a entidade fraca e a entidade forte, chamado de relacionamento identificador.

- Chave Parcial: A entidade fraca possui uma chave parcial que, combinada com a chave primária da entidade forte, forma a chave primária composta.

# Relacionamento Grau

- Relacionamento Binários
	- Aluno (entidade)
	- Curso (entidade)
	- Matricula (relacionamento)

- Relacionamento Ternário
	- Paciente (entidade)
	- Médico (entidade)
	- Hospital (entidade)
	- Tratamento (relacionamento)

- Número de Entidades: Relacionamentos binários envolvem duas entidades, enquanto relacionamentos ternários envolvem três entidades.

- Complexidade: Relacionamentos ternários são mais complexos e podem representar interações mais detalhadas entre entidades, comparado com relacionamentos binários.

# Constraints - Cardinalidade

- Cardinalidade
A cardinalidade, no contexto de relações, refere-se ao número de tuplas (linhas) em uma relação. Em outras palavras, é o total de registros presentes na tabela.

Exemplo: Se a tabela "Funcionários" tiver 5 registros (linhas), sua cardinalidade será 5.

Além disso, a cardinalidade também é usada para descrever relações entre tabelas em um banco de dados, como:

1:1 (um para um): Cada linha de uma tabela está associada a uma única linha de outra tabela.

1:N (um para muitos): Uma linha de uma tabela pode estar associada a várias linhas de outra tabela.

N:M (muitos para muitos): Várias linhas de uma tabela podem estar associadas a várias linhas de outra tabela.

# Entidade Fraca

- Tipos de Entidades
	- Fracas
		- Dependem de outra
	- Relacionamento ID (interligadas)
	- Fortes
		- Owner Entity Type

# Notações DER

- Entidades: Classes/Objetos --> Retângulo
- Relacionamentos: Agregações --> losango
- Atributos: Propriedades elementares --> eclipse
- Weak: Entidades, relacionamentos
- Chave Parcial: Linha pontilhada
- Chave principal: linha continua
- Dependência de existência: ||
- Atributo derivado
- Atributo composto
- Participação total
- Cardinalidade 
- Constraint estrutural
# Relacionamento N-ário
- Ternário,..., N-ário
- Perspectiva diferente do binário


==== Modelagem de Dados com EER ====
- Modelo ER 1970
- EER: Novos Conceitos Semânticos
- Desenvolvidos fora da área de BDs
- Digrama ERR

# Modelo Enhanced ER
- Superclasses
- Herança
- Subclasses
	- Depende do contexto do BD
	- Objeto distinto no BD
	- Herança de Superclasse
- Generalização e Especialização
- Categoria ou Union Type
- Herança: Atributo e relacionamento

# Herança

"Princípio próprio á programação orientada a objetos (POO) que permite criar uma nova classe a partir de uma já existente."

- Reutilização de código
- Especialização de classes
- Agregar atributos e métodos

# Especialização e Generalização

- Generalização: Combina múltiplas entidades específicas em uma entidade genérica (movimento de "baixo para cima").
- Exemplo: Entidades Carro e Caminhão podem ser generalizadas para Veículo.

- Especialização: Divide uma entidade genérica em entidades mais específicas (movimento de "cima para baixo").
- Exemplo: Veículo pode ser especializado em Carro e Caminhão.

# [1:1]
- instâncias das superclasse e subclasses
- Mesma representação de mundo real
- Papel especializado

# Diferença Fundamental:
A generalização foca em encontrar semelhanças e agrupar o que é comum, enquanto a especialização foca em identificar diferenças e detalhar o que é único.

# Constraints - Modelo EER 
- Predicated-defined (condição)
	- Definição: Aqui, a divisão de um supertipo em subtipos 	é feita com base em condições lógicas ou predicados.
- Attribute-defined Specialization
	- Definição: A especialização ou generalização é guiada 	por valores específicos de um atributo no supertipo.
- User-defined
	- Definição: Neste caso, não há predicados ou atributos 	claramente definidos. A categorização é baseada na 	decisão manual do usuário.

# Hierárquica & Rede de Especialização
- Hierarquia de especialização
- Rede de especialização

# Estrutura no Modelo

- Categorização: Não altera a estrutura das entidades. Cada uma mantém seus atributos e relacionamentos. A categorização é mais como "etiquetas" ou identificadores.
- Exemplo: Na categorização, você identifica Cliente VIP sem mudar a estrutura da tabela de Clientes.

- Union Types: Requer a criação de uma nova entidade que abstrai ou agrega entidades distintas. Isso pode alterar a forma como os relacionamentos e atributos são modelados.
- Exemplo: Ao criar um Union Type como UsuárioBiblioteca, atributos ou relacionamentos comuns (como Data de Empréstimo) são migrados para o tipo unificado.

# Terminologias

- Knowledge representation (KR)

- Ontologia

# Conceitos Modelo Relacional
- Modelo Relacional
	- Coleção de Relação
		- Classes
		- Objetos
- Tabelas x Arquivos
- Entidade
- tabela --> Relação
- Tupla --> linha || instância || registro
- Atributo --> propriedade/Coluna da relação

# O que é Lógica de Predicado?
A lógica de predicado é um ramo da lógica matemática que estuda proposições com variáveis e quantificadores, como "para todo" (∀) e "existe" (∃). Diferente da lógica proposicional (que usa apenas proposições simples), a lógica de predicado permite descrever relações entre objetos e suas propriedades de forma mais detalhada.
Por exemplo:
	- Proposição: "Maria é uma estudante."
	
	- Lógica de Predicado: Estudante(Maria), onde "Estudante" é um predicado que define uma propriedade da variável "Maria".
	
- Consultas SQL: A lógica de predicado influencia a forma como as consultas são formuladas. Um comando SQL, como SELECT, é semelhante à aplicação de predicados para filtrar ou projetar os dados.


# Domínio
O domínio refere-se ao conjunto de valores possíveis que um atributo pode assumir. É como uma "regra" que define os valores válidos para determinada coluna.

Exemplo: Se o atributo "Idade" tiver um domínio definido como números inteiros entre 18 e 65, isso significa que somente valores dentro desse intervalo serão aceitos para essa coluna.

O domínio garante que os dados armazenados sejam válidos e consistentes com as restrições aplicadas.

# Constraints Modelo Relacional

- Integridade dos Dados: Garantem que os dados sejam válidos e consistentes com as regras do sistema.

- Prevenção de Erros: Evitam a entrada de dados inválidos.

- Automatização de Regras de Negócio: Muitas regras podem ser implementadas diretamente no design do banco de dados.

- DDL --> Data Definition Language --> Create, Drop, Insert, Rename
- DML --> Data Manipulation Language --> Insert, Update, Delete, Merge
- DCL --> Data Control Language --> Grant, Revoke
- DQL - Data Query Language --> Select

- Integridade Referencial: É uma regra que mantém os relacionamentos entre tabelas consistentes, garantindo que não haja referências a dados inexistentes em tabelas relacionadas.

- Chave Estrangeira (Foreign Key): É um campo em uma tabela que cria o vínculo com a chave primária de outra tabela, assegurando a integridade referencial.

# Relacionamentos 1:1

geralmente existem duas opções para o mapeamento relacional:
1. Unir as tabelas: Incorporar os atributos de uma entidade na tabela da outra.
2. Usar chaves estrangeiras: Cada entidade mantém sua tabela, e o relacionamento é representado por uma chave estrangeira.
	1. Use a primeira abordagem quando o relacionamento é altamente dependente e quase inseparável.

	2.	A segunda abordagem é preferida quando as entidades têm identidades próprias e podem existir separadamente.

# Um relacionamento binário 1:N 

(um para muitos) ocorre quando uma entidade A se associa a várias entidades B, mas cada entidade B está associada a apenas uma entidade A.

1. Identificar as Entidades e o Relacionamento:
Exemplo: Entidade Cliente (1) e Pedido (N).

Um cliente pode fazer vários pedidos, mas cada pedido está associado a um único cliente.

2. Definir o Relacionamento:
A tabela que representa o lado "muitos" (Pedidos) conterá uma chave estrangeira que referencia a tabela do lado "um" (Clientes).

# Relacionamento N:M

Mapeamento de relacionamentos binários N:M (muitos para muitos) é um conceito comum em modelagem de banco de dados relacional e análise de sistemas. Ele representa uma associação onde múltiplas entidades de um lado podem estar relacionadas a múltiplas entidades do outro lado.

Esse modelo permite rastrear facilmente as associações entre as duas entidades e facilita a consulta ou manipulação de dados. Posso detalhar mais, se precisar de algo específico! 😊

=========== SQL ===========
- DDL --> Data Definition Language
	- Create | Drop | Alter
	- Insert | Update | Delete
	- Rename | Truncate | Merge
- User
- Schema
- Statementss
- INDEXING

# DDL (Data Definition Language)
Propósito: Definir e modificar a estrutura do banco de dados.

Comandos comuns:

CREATE: Cria novos objetos no banco de dados, como tabelas e índices.

ALTER: Modifica a estrutura de objetos existentes.

DROP: Remove objetos do banco.

TRUNCATE: Remove todos os registros de uma tabela, mantendo sua estrutura.

Foco: Gerencia a definição e organização do banco de dados.

Reversibilidade: As alterações geralmente não podem ser revertidas (exemplo: ao usar DROP).

# DML (Data Manipulation Language)
Propósito: Manipular dados armazenados nas tabelas.

Comandos comuns:

SELECT: Recupera dados.

INSERT: Insere novos registros.

UPDATE: Atualiza registros existentes.

DELETE: Remove registros.

Foco: Lida com os dados propriamente ditos, sem modificar a estrutura das tabelas.

Reversibilidade: As alterações realizadas podem ser desfeitas dentro de uma transação (usando ROLLBACK).

# DCL (Data Control Language)
Propósito: Gerenciar permissões e segurança no banco de dados.

Comandos principais:

GRANT: Concede permissões a usuários ou papéis para acessar e realizar ações no banco de dados.

Exemplo: GRANT SELECT, INSERT ON clientes TO usuarioX;

REVOKE: Revoga permissões previamente concedidas.

Exemplo: REVOKE INSERT ON clientes FROM usuarioX;

Foco: Controlar quem pode acessar ou modificar os dados e as estruturas do banco.

# DQL (Data Query Language)
Propósito: Consultar dados do banco de dados.

Comando principal:

SELECT: É a base do DQL e permite buscar dados de uma ou mais tabelas.

Exemplo: SELECT nome, email FROM clientes WHERE cidade = 'Rio de Janeiro';

Foco: Extrair e visualizar informações armazenadas no banco de dados.

# Constraints

PRIMARY KEY: Garante que cada registro de uma tabela seja único.

FOREIGN KEY: Estabelece uma relação entre duas tabelas, ligando uma chave de uma tabela à chave primária de outra:

NOT NULL: Impede que uma coluna tenha valores nulos:

UNIQUE: Garante que todos os valores em uma coluna sejam únicos:

CHECK: Define uma condição para os valores de uma coluna:

DEFAULT: Especifica um valor padrão para uma coluna, caso não seja fornecido nenhum valor:

# Teoria por Trás dos Alias
	Um alias é simplesmente um nome alternativo, temporário e amigável atribuído a colunas ou tabelas dentro de uma consulta SQL. Ele serve para melhorar a legibilidade do código ou facilitar a referência a elementos complexos (como colunas calculadas ou subconsultas). Um alias não altera os nomes reais no banco de dados, apenas os renomeia durante a execução da consulta.

Expressões em SQL
	As expressões são usadas para realizar operações ou cálculos no SELECT. Elas podem incluir operadores aritméticos, funções, concatenações de strings e muito mais. Exemplos de expressões comuns incluem:

	SELECT preço * quantidade AS total FROM vendas;

	SELECT nome || ' ' || sobrenome AS nome_completo FROM clientes;
	No exemplo acima, usamos || (em alguns bancos) para concatenar nome e sobrenome.

# LIKE
	O operador LIKE é usado em consultas SQL para buscar padrões específicos em colunas de texto. Ele funciona com curingas para tornar as buscas flexíveis:
	%: Representa zero ou mais caracteres.
´´
	SELECT * FROM clientes
	WHERE nome LIKE 'Jo%';
´´
	Isso vai retornar todos os clientes cujos nomes começam com "Jo", como "Joana" ou "José".

# Outro exemplo:
	_: Representa um único caractere.
``
	SELECT * FROM produtos
	WHERE descricao LIKE '_ola';
``
	Isso busca algo como "bola", "cola", etc., já que o _ exige exatamente um caractere antes de "ola".

# BETWEEN
	O operador BETWEEN é usado para buscar valores dentro de um intervalo. Ele funciona para tipos como números, datas e até texto (seguindo a ordem alfabética).
	- Exemplo com números:
``
	SELECT * FROM vendas
	WHERE preco BETWEEN 50 AND 100;
``
	Isso retorna todas as vendas com preços entre 50 e 100, incluindo os limites.

# Exemplo com datas:
``
	SELECT * FROM pedidos
	WHERE data BETWEEN '2025-01-01' AND '2025-03-31';
``
	Aqui, você vai obter todos os pedidos feitos nesse trimestre.

# UNION
	O operador UNION combina os resultados de duas ou mais consultas, eliminando duplicatas por padrão. Os conjuntos devem ter o mesmo número e tipo de colunas para funcionar.
``
	SELECT nome, email FROM clientes_brasil
	UNION
	SELECT nome, email FROM clientes_mexico;
``
	Esse comando retorna uma lista unificada de clientes do Brasil e do México, sem duplicatas.

# INTERSECT
	O operador INTERSECT retorna apenas as linhas que estão presentes em ambas as consultas.
``
	SELECT nome FROM clientes_brasil
	INTERSECT
	SELECT nome FROM clientes_mexico;
``
	Isso mostrará apenas os clientes que estão tanto na base do Brasil quanto na do México.

# EXCEPT
	O operador EXCEPT retorna as linhas que estão na primeira consulta, mas não estão na segunda.
``
	SELECT nome FROM clientes_brasil
	EXCEPT
	SELECT nome FROM clientes_mexico;
``
	Isso listará os clientes que estão apenas no Brasil e não no México.

Considerações:
	Essas operações seguem a estrutura de colunas compatíveis (mesmo número e tipo de colunas).

	A ordem das colunas e os nomes das tabelas podem importar para interpretações mais complexas.

	O suporte a INTERSECT e EXCEPT pode variar entre bancos de dados (alguns, como o MySQL, não possuem nativamente, mas há alternativas).

Uma Nested Query (ou consulta aninhada)
	em SQL é uma consulta dentro de outra consulta. A consulta interna (ou subconsulta) é executada primeiro e o resultado é usado pela consulta externa. Essas subconsultas são geralmente usadas em instruções SELECT, INSERT, UPDATE ou DELETE para realizar operações mais complexas ou filtragens.

A keyword IN em SQL 
	é usada para especificar múltiplos valores em uma cláusula WHERE. É uma maneira prática de verificar se um valor está dentro de uma lista de valores fornecidos, em vez de usar várias condições combinadas com OR. Isso simplifica e torna as consultas mais legíveis.

=== Cláusulas
	EXISTS: TRUE se o resultado da consulta aninhada contiver pelo menos uma tupla;

	NOT EXISTS: TRUE se o resultado da consulta aninhada não contiver tuplas;

	UNIQUE: Retornar TRUE se é único;

# SQL ORDER  BY
	A cláusula SQL ORDER BY é usada para organizar os resultados de uma consulta em ordem ascendente (ASC) ou descendente (DESC), com base em uma ou mais colunas. Por padrão, a ordem é crescente.

# Agrupamento de Registros;
	Agregar | Aglutinar | agrupar
	O GROUP BY é uma cláusula no SQL usada para agrupar linhas que têm valores semelhantes em colunas específicas. Ele é muito útil para agregar dados e gerar resumos usando funções como COUNT(), SUM(), AVG(), MAX() e MIN().

==== Join ==== 
O que é JOIN?
	O JOIN é usado para combinar linhas de duas ou mais tabelas com base em uma condição lógica.
	Geralmente, relacionamos tabelas usando uma chave primária de uma tabela e uma chave estrangeira de outra.

Tipos de JOIN:
	INNER JOIN (ou simplesmente JOIN): Retorna apenas as linhas que têm correspondência em ambas as tabelas.

	LEFT JOIN (ou LEFT OUTER JOIN): Retorna todas as linhas da tabela à esquerda (A), mesmo que não haja correspondência na tabela à direita (B). Linhas sem correspondência em B terão valores NULL.

	RIGHT JOIN (ou RIGHT OUTER JOIN): Retorna todas as linhas da tabela à direita (B), mesmo que não haja correspondência na tabela à esquerda (A). Linhas sem correspondência em A terão valores NULL.

	FULL JOIN (ou FULL OUTER JOIN): Retorna todas as linhas de ambas as tabelas. Linhas sem correspondência em uma das tabelas terão valores NULL.

	CROSS JOIN: Retorna o produto cartesiano de ambas as tabelas (todas as combinações possíveis de linhas entre as tabelas).

	SELF JOIN: É um JOIN de uma tabela com ela mesma. Útil para comparar linhas dentro da mesma tabela.

# CASE WHEN THEN ELSE END
	A declaração CASE é usada para realizar condições dentro de uma consulta SQL e retornar valores baseados nessas condições. Ela é parecida com um "if-else" em programação.
	Dicas:
	Você pode usar o CASE em praticamente qualquer lugar: em SELECT, WHERE, UPDATE, ORDER BY ou até mesmo HAVING.

	É uma ótima maneira de criar categorias e personalizar os resultados dsa sua consulta.

# O que são views?
	Uma view (ou visão) é essencialmente uma consulta armazenada no banco de dados, que pode ser tratada como uma tabela virtual. Essa tabela virtual não armazena dados diretamente; em vez disso, ela exibe os dados provenientes de outras tabelas, baseando-se na consulta que a define. Pense nisso como uma "janela" para os dados, que facilita visualizações personalizadas e organizadas.

# Por que utilizar views?
	Aqui estão alguns motivos principais para utilizar views:
	
	1. Simplicidade: Elas podem simplificar consultas complexas. Por exemplo, se você tem uma consulta complicada que é usada frequentemente, pode transformá-la em uma view.
	
	2. Segurança: É possível restringir o acesso a determinados dados. Por exemplo, você pode criar uma view que só mostre certas colunas de uma tabela, ocultando outras.

	3. Manutenção de dados: Ajuda a criar camadas de abstração. Se a estrutura das tabelas subjacentes mudar, basta ajustar a view, sem a necessidade de alterar as consultas em várias partes do aplicativo.

	4. Reutilização: Podem ser reutilizadas em diferentes partes do sistema, reduzindo redundâncias no código SQL.

# Restrições e limitações de views
	Apesar dos benefícios, as views têm algumas restrições e limitações:

	1. Somente leitura: Algumas views podem ser somente leitura, especialmente se contiverem operações complexas como JOIN, agregações (SUM, AVG), ou DISTINCT.

	2. Performance: Como são baseadas em consultas, o uso excessivo de views pode impactar o desempenho, especialmente em bancos com grande volume de dados.

	3. Atualizações: Nem todas as views podem ser atualizadas diretamente. Quando possível, isso depende de como a view foi definida
	
	4. Dependência: Alterações na estrutura das tabelas subjacentes podem exigir ajustes nas views  

# Atomicidade - ACID
	A atomicidade significa que uma transação no banco de dados deve ser tratada como uma unidade única e indivisível. Ou seja, ou todas as operações dentro de uma transação são concluídas com sucesso, ou nenhuma delas é aplicada. Isso evita que dados sejam deixados em um estado inconsistente.

	Por exemplo, imagine que você está transferindo dinheiro de uma conta para outra:
	1. Debitar da Conta A.
	2. Creditar na Conta B
	
	Se ocorrer um erro depois de debitar a Conta A, mas antes de creditar na Conta B, a atomicidade garante que a transação será revertida, mantendo as contas como estavam antes da operaç

# SQL Dinamico
	SQL dinâmico é uma técnica utilizada para construir instruções SQL de forma flexível e adaptável. Ou seja, em vez de escrever consultas SQL estáticas, podemos criar scripts que geram essas consultas dinamicamente com base em variáveis ou condições específicas. Isso é especialmente útil quando precisamos adaptar a consulta de acordo com os dados fornecidos pelo usuário ou requisitos específicos do programa.
	
	# Por que usar SQL dinâmico?
		Adaptabilidade: Permite construir consultas em tempo de execução.
		Flexibilidade: Ideal para cenários onde não sabemos antecipadamente a estrutura exata da consulta.
		Automatização: Reduz a necessidade de criar múltiplas consultas estáticas para diferentes cenários.
	
	Como funciona na prática? Vamos ao exemplo! Imagine que queremos consultar uma tabela chamada "Produtos" e filtrar os resultados com base em critérios que só descobriremos na execução. O SQL dinâmico pode ser criado assim:
	DECLARE @sql NVARCHAR(MAX);
	DECLARE @categoria NVARCHAR(50);

	SET @categoria = 'Eletrônicos';

	SET @sql = 'SELECT * FROM Produtos WHERE Categoria = ''' + @categoria + '''';

	EXEC sp_executesql @sql;

	A variável @categoria armazena o filtro desejado
	A instrução SQL é concatenada usando a variável, criando uma consulta personalizada.
	sp_executesql executa o SQL dinâmico gerado.

	# Cuidados ao usar SQL dinâmico:
		Segurança: Evite vulnerabilidades de SQL Injection. Sempre valide os dados inseridos pelo usuário
		
		Desempenho: Pode ser menos eficiente do que consultas estáticas. Use com moderação.

		Legibilidade: Pode dificultar a manutenção do código, então documente bem.

# O que é uma stored procedure?
	Uma stored procedure (ou "procedimento armazenado") é basicamente um conjunto de comandos SQL que é salvo no banco de dados e pode ser reutilizado sempre que necessário. Pense nela como uma função no mundo da programação: você escreve o código uma vez, armazena no banco e pode chamá-lo sempre que precisar executar aquela lógica.
	
	# Por que usar stored procedures?
		- Reutilização: Pode ser chamada várias vezes sem precisar escrever o mesmo código repetidamente.
		- Eficiência: Reduz o tráfego entre a aplicação e o banco de dados, já que o código é executado no servidor de banco.
		- Segurança: Pode controlar o acesso, permitindo que usuários executem a procedure sem precisar visualizar diretamente os dados do banco
		- Manutenção: Facilita as alterações, pois você edita o código em um único lugar.
	
	# Procedures Parametros
		IN (Parâmetro de Entrada)
			- O que é? É usado para passar valores para a procedure.
			- Característica: Os valores do parâmetro não podem ser alterados dentro da procedure. Eles são apenas lidos.
		
		OUT (Parâmetro de Saída)
			- O que é? É usado para retornar valores da procedure para quem a chamou.
			- Característica: Não tem valor inicial; ele será atribuído dentro da procedure.

		INOUT (Parâmetro de Entrada e Saída)
			- O que é? É usado para receber um valor como entrada e retornar um valor como saída.
			- Característica: Permite modificar o valor do parâmetro dentro da procedure.

	# Exemplo de stored procedure:
		Vamos criar uma procedure que retorna os produtos de uma determinada categoria:
		CREATE PROCEDURE GetProdutosPorCategoria
    @Categoria NVARCHAR(50) -- variable
		AS
		BEGIN -- inicio
				SELECT * FROM Produtos
				WHERE Categoria = @Categoria;
		END; -- fim
	Como usar essa stored procedure?
	Depois de criar a procedure, podemos executá-la assim:
	EXEC GetProdutosPorCategoria @Categoria = 'Eletrônicos';
	
	Vantagens adicionais:
		Ajuda a organizar melhor o código SQL.
		É ótima para cenários onde há muita lógica complexa.
	
	Cuidado:
		Como em qualquer outro recurso, use com sabedoria para evitar consultas que possam afetar o desempenho do banco.

# O Que é Condition Handling?
	Quando algo dá errado, como uma divisão por zero ou uma violação de restrição, o MySQL gera uma condição. Para lidar com essas condições, usamos handlers dentro de Stored Procedures ou Triggers. Um Handler informa ao SQL como reagir a um erro ou aviso específico
	
	# Estrutura Básica de um Handler
		Um handler é configurado dentro de uma procedure com a seguinte estrutura:
		DECLARE tipo_do_handler HANDLER FOR condição_específica 
    ação_a_ser_executada;

		tipo_do_handler: Define como o handler funciona
			CONTINUE: Ignora o erro ou condição e prossegue para a próxima instrução.
			EXIT Sai imediatamente da procedure ou bloco.
		
		condição_específica: Define o tipo de condição que o handler captura, como:
			SQLEXCEPTION: Captura qualquer erro SQL.
			SQLWARNING: Captura alertas.
			NOT FOUND: Captura situações onde um resultado esperado não foi encontrado.
	
	# Exemplo 1: Tratando SQLEXCEPTION com CONTINUE
		Imagine que queremos capturar erros e continuar a execução:
		DELIMITER $$
			CREATE PROCEDURE exemplo_handler()
			BEGIN
					DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
							SET @erro = 'Ocorreu um erro, mas estamos continuando!';
					
					-- Tentativa de divisão por zero (gera erro)
					SET @resultado = 10 / 0;

					-- O próximo código será executado mesmo após o erro
					SET @mensagem = 'Execução continuada após o erro!';
					SELECT @mensagem;
			END $$
		DELIMITER ;

	# Exemplo 2: Tratando NOT FOUND com EXIT
		Este exemplo lida com situações em que nenhum dado é encontrado, e encerra o bloco.
		DELIMITER $$
			CREATE PROCEDURE exemplo_not_found()
			BEGIN
					DECLARE EXIT HANDLER FOR NOT FOUND
							SET @mensagem = 'Nenhum dado encontrado!';
					
					-- Tentativa de buscar um dado inexistente
					SELECT nome INTO @resultado FROM usuarios WHERE id = -1;
					
					-- Se nenhum dado for encontrado, o handler será acionado
					SELECT @mensagem;
			END $$
		DELIMITER ;
	Resultado: A execução termina com uma mensagem caso nenhum dado seja encontrado.

	# Por que Usar Condition Handling?
		- Robustez: Garante que o código lide com problemas sem falhas graves.
		- Personalização: Permite mostrar mensagens mais informativas.
		- Controle: Dá flexibilidade para decidir como proceder em diferentes situações.
	
	# 1. Objetivo e Uso
		Procedures (Procedimentos): São usadas principalmente para executar ações complexas e processos. Podem incluir múltiplas operações como inserir, atualizar ou consultar dados.
			Exemplo: Executar vários cálculos, modificar tabelas ou interagir com múltiplos registros.
			Normalmente chamadas diretamente com CALL.
		
		Functions (Funções): São usadas para retornar um único valor baseado em um cálculo ou operação. Geralmente utilizadas dentro de queries SQL:
			Exemplo: Retornar o total de vendas ou calcular impostos.
			Chamadas diretamente em expressões SQL como SELECT minha_funcao().
	
	# 2. Forma de Chamada
		CALL minha_procedure(parametros);
		SELECT minha_funcao(parametros);
	
	# 3. Saída
		Procedures: Podem ter múltiplas saídas, seja por meio de variáveis ou manipulação de tabelas. Elas não são usadas diretamente dentro de queries.

		Functions: Devem retornar exatamente um valor (como números, textos ou resultados calculados), sendo frequentemente usadas dentro de .
	
	# 4. Utilização em Queries
		Procedures: Não podem ser usadas diretamente em queries SQL, apenas chamadas com CALL.
		
		Functions: Podem ser integradas em queries SQL.
			Exemplo:
				SELECT minha_funcao(parametros) AS resultado;
	
	# 5. Manipulação de Dados
		Procedures: Podem modificar dados, incluindo inserções, atualizações ou exclusões em tabelas.
		
		Functions: Não devem modificar dados diretamente; são limitadas ao cálculo e retorno de valores.

# Assertions no MySQL:
	CHECK constraints: O MySQL não oferece suporte direto a essa funcionalidade, comum em outros bancos de dados.

	Alternativas: Verificações podem ser simuladas com triggers ou através da lógica no seu aplicativo.

# Implementação com Triggers:
	Triggers permitem executar ações antes ou depois de eventos como inserções ou atualizações.

	Exemplo: Validar se a idade é maior ou igual a 18 antes de inserir na tabela pessoas;
	CREATE TRIGGER valida_idade_insere 
		BEFORE INSERT ON pessoas 
		FOR EACH ROW 
		BEGIN
				IF NEW.idade < 18 THEN
						INSERT INTO mensagens_erro (mensagem) VALUES ('Idade deve ser maior ou igual a 18.');
						SIGNAL SQLSTATE '45000'
						SET MESSAGE_TEXT = 'Erro de validação no trigger.';
				END IF;
		END;

# Principais cenários em que é ideal usar triggers:
	1. Garantia de Integridade dos Dados
		Quando você quer assegurar que regras específicas de negócios ou restrições sejam aplicadas automaticamente.

		Exemplo: Validar que a idade de um usuário seja maior ou igual a 18 antes de inserir o registro.

	2. Auditoria de Dados (Histórico)
		Para rastrear alterações ou eventos no banco de dados sem necessidade de intervenção manual.
		
		Exemplo: Registrar em uma tabela de logs quem alterou um registro ou o horário da alteração.
				CREATE TRIGGER log_alteracao
				AFTER UPDATE ON usuarios
				FOR EACH ROW
				INSERT INTO logs (usuario_id, data_alteracao)
				VALUES (OLD.id, NOW());
	
	3. Automação de Tarefas Repetitivas
		Executar ações automaticamente, como atualizar um status ou calcular valores derivados.
	
		Exemplo: Atualizar o estoque automaticamente quando um pedido é registrado.
	
	4. Aplicação de Regras de Negócio
		Quando algumas regras precisam ser reforçadas automaticamente no banco.

		Exemplo: Evitar que valores negativos sejam inseridos em uma coluna de saldo.
	
	5. Consistência entre Tabelas
		Garantir consistência ou sincronização de dados entre tabelas relacionadas.

		Exemplo: Excluir registros associados em uma tabela filha quando o registro correspondente na tabela pai é deletado (emular ON DELETE CASCADE).

# Cuidados ao Usar Triggers:
	1. Desempenho: Triggers podem impactar o desempenho se não forem bem projetados, especialmente em tabelas com grande volume de dados.

	2. Complexidade: Evite lógica muito complexa em triggers, pois isso pode tornar a manutenção do banco de dados mais difícil.

	3. Debugging: Localizar problemas em triggers pode ser desafiador, já que eles são executados automaticamente nos bastidores.

# Índices em MySQL
	Quando você declara uma primary key, o sistema automaticamente cria um índice para otimizar a busca e manipulação dos dados. Mas o que exatamente é um índice?
	Um índice é uma estrutura de dados utilizada para localizar registros em uma tabela de maneira eficiente. Em MySQL, os índices geralmente utilizam a estrutura de dados B+ tree (árvore B+), que organiza os valores de forma hierárquica, facilitando buscas rápidas.

	Na memória, um índice armazena dois principais componentes:
		1. Campo de indexação: Este é o valor utilizado para ordenar e identificar os registros.

		2. Ponteiro: Um endereço que aponta para a localização física do registro no armazenamento (disco), onde os dados reais estão salvos

	Dessa forma, o índice atua como um mapa, agilizando as operações de busca, inserção e atualização ao reduzir a necessidade de varrer toda a tabela.

	# Como o MySQL Trabalha com Índices?
		Quando você cria um índice não-clustered, como idx_nome, o MySQL armazena o índice como uma estrutura de dados separada (geralmente uma árvore B+) que contém:
			1. Os valores indexados da coluna (nome, no caso do índice idx_nome).
			2. Ponteiros para os registros reais na tabela. Esses ponteiros podem ser:
				Para o índice clustered (em tabelas InnoDB), onde os dados reais estão armazenados.
				Para o local no disco (em tabelas MyISAM).
	
		# Por Que Isso é Rápido?
			Estrutura de Árvore B+:
				Tanto o índice não-clustered quanto o índice clustered são armazenados como árvores B+. Essas árvores permitem acesso em tempo logarítmico 
				
				(O(log n)), o que significa que mesmo para tabelas muito grandes, o número de operações de busca é pequeno.
				
				Exemplo: Se você tiver 1 milhão de registros, a árvore B+ talvez precise de apenas 20 verificações para encontrar o valor.
		
		# Nenhum Percorrimento Linha a Linha:
			Graças à estrutura de índice ordenado, o MySQL não precisa fazer uma varredura completa na tabela (full table scan).
			
			Ele vai diretamente ao registro desejado utilizando os índices e os ponteiros.
		
		# Como Isso Funciona na Prática
			Vamos ilustrar como o índice idx_nome trabalha:
			O índice idx_nome contém algo assim:
				"Ana Costa" → Ponteiro para o índice clustered
				"Carlos Mendes" → Ponteiro para o índice clustered
				"Jhean Silva" → Ponteiro para o índice clustered
				"Mariana Oliveira" → Ponteiro para o índice clustered
			
			Ao buscar 'Jhean Silva':
				O MySQL localiza 'Jhean Silva' no índice idx_nome usando busca eficiente na árvore B+.
				Depois, o ponteiro leva diretamente ao índice clustered.

			No índice clustered, o MySQL acessa o registro completo, como
				id: 1, nome: 'Jhean Silva', email: 'jhean@gmail.com', cidade: 'Rio de Janeiro'
				
	# Tipos de Índices no MySQL
		1. Primary Key: É um índice único que identifica cada linha da tabela. Sempre é criado automaticamente quando você define a chave primária de uma tabela.
	
		2. Unique Index: Garante que todos os valores no campo sejam únicos.

		3. Index Normal: Um índice padrão que acelera as buscas, mas permite valores duplicados.

		4. Full-Text Index: Usado para pesquisas de texto, ideal para campos que contêm grandes blocos de texto, como artigos ou descrições

		5. Spatial Index: Usado para dados geoespaciais (no tipo de dado geometry).

	# Como Criar um Índice?
		Você pode criar índices ao definir a tabela ou posteriormente. Veja os exemplos
		Ao criar uma tabela:
		CREATE TABLE funcionarios (
			id INT AUTO_INCREMENT PRIMARY KEY,
			nome VARCHAR(50),
			salario DECIMAL(10,2),
			INDEX (nome)
		);
	
		Após criar uma tabela:
			CREATE INDEX idx_nome ON funcionarios(nome);

Os índices hash são uma técnica de indexação que utiliza funções de hash para mapear os valores de uma coluna diretamente para um local específico na tabela. Eles são extremamente rápidos para buscas exatas (ou seja, quando você busca por um valor exato em uma coluna), mas possuem limitações que precisam ser compreendidas para serem usados de forma eficiente.
	
	# Como Funciona um Índice Hash?
		1 - Função de Hash:
			A função de hash pega o valor da coluna e gera um código ou chave única chamado "hash". Por exemplo, o valor 'Jhean Silva' pode ser transformado em algo como AB123.

	2 - Mapa de Hash: 
		O banco de dados utiliza esse código para localizar diretamente o registro correspondente na tabela. É como usar um endereço único para acessar a linha desejada, sem precisar percorrer outros registros.

	3 - Processo de Busca:- Quando você faz uma consulta como 
		WHERE nome = 'Jhean Silva', o índice hash transforma 'Jhean Silva' na chave AB123 e acessa diretamente o local do dado. Isso elimina a necessidade de varreduras ou buscas sequenciais.

	#Vantagens dos Índices Hash
		1. Velocidade em Buscas Exatas:
			índices hash são extremamente rápidos em consultas que usam igualdade (=). Por exemplo:
				SELECT * FROM clientes WHERE nome = 'Jhean Silva';

		2. Menor Overhead:
			Consomem menos espaço do que outros tipos de índices, como os baseados em árvores B+.

		3. Simples e Diretos:
			São mais simples de implementar e gerenciar, já que lidam com um único mapeamento de valor para chave.

	# Desvantagens dos Índices Hash
		1. Inadequado para Consultas em Intervalo
			Não funcionam bem em consultas como:
				SELECT * FROM clientes WHERE id BETWEEN 10 AND 20;
			Isso ocorre porque os índices hash não preservam a ordem dos valores.

		2. Colisões de Hash:
			Em casos raros, dois valores diferentes podem gerar o mesmo código de hash (colisão). O banco de dados precisa lidar com essas colisões, o que pode reduzir a eficiência

		3. Incompatível com LIKE ou ORDER BY:
			Consultas que usam LIKE '%Silva%' ou ordenação não se beneficiam de índices hash.

		4. Dependente da Função de Hash:
			A eficiência depende diretamente da qualidade da função de hash utilizada pelo sistema.

	# Exemplo Prático
		Embora o MySQL não utilize índices hash diretamente para tabelas InnoDB (que preferem árvores B+), você pode encontrá-los em outros sistemas, como o mecanismo de armazenamento Memory Engine no MySQL.

		# Criação de Índice Hash no MySQL:
			CREATE TABLE clientes (
				id INT PRIMARY KEY,
				nome VARCHAR(50),
				email VARCHAR(100),
				cidade VARCHAR(50)
			) ENGINE=MEMORY;
		CREATE INDEX idx_nome_hash ON clientes(nome) USING HASH;
			Busca Exata:
				SELECT * FROM clientes WHERE nome = 'Jhean Silva';
			Nesse caso, o índice hash será usado para localizar 'Jhean Silva' de forma extremamente rápida.

	# Quando Usar Índices Hash?
		Índices hash são ideais para:
			- Consultas que exigem igualdade exata (=).
			- Colunas com valores únicos ou baixa cardinalidade (como identificadores ou status simples).
		Eles não são recomendados para:
			- Consultas em intervalos (BETWEEN, <, >) ou ordenadas (ORDER BY).
			- Situações que exigem ordenação ou busca textual (LIKE).
	
	# Estrutura dos Índices Hash
		Os índices hash não possuem ponteiros convencionais como índices não-clustered, mas em vez disso, utilizam diretamente uma função de hash para mapear valores da coluna a um local específico onde o registro correspondente pode ser acessado. Vamos explorar os conceitos envolvidos:
	
	# Busca Binária vs. Função de Hash
		1. Função de Hash
			- A função de hash transforma o valor em uma "chave hash". Essa chave serve como um identificador único que corresponde diretamente a um espaço ou local onde o dado é armazenado.

			- Não é necessário realizar uma busca binária para encontrar o hash, porque o cálculo do hash é feito diretamente pelo algoritmo. O processo é instantâneo: dado o valor de entrada, a função gera o hash.

		2. Localização do Dado no Disco:
			- Uma vez que o valor é convertido em um hash, o índice hash mapeia diretamente para o local onde os dados estão armazenados. O banco de dados acessa o registro correspondente no disco ou na memória usando essa chave hash.

	# O Fluxo de Busca com Índices Hash
		Aqui está como funciona a busca com índices hash:
			
			1. Entrada: Quando você faz uma consulta como WHERE nome = 'Jhean Silva', o banco de dados aplica a função de hash para calcular o código hash de 'Jhean Silva'.
			
			2. Hash como Endereço: O código hash gerado é usado para acessar diretamente o bloco de memória ou disco que contém o registro desejado.
			
			3. Dado Real: Finalmente, o registro completo é lido e retornado na resposta da consulta.

	# Por Que Índices Hash Não Fazem Busca Binária?
		A busca binária é usada em estruturas ordenadas, como árvores B+. No caso dos índices hash:
			- O dado não está ordenado; ele é mapeado diretamente por uma função de hash.
			
			- A eficiência da busca vem do fato de que o hash atua como uma referência direta ao local do registro.
	O processo elimina a necessidade de percorrer ou comparar valores, tornando os índices hash ideais para buscas exatas.

	# Como o Índice Hash Lida com Valores que Não Existem
		Quando você usa uma cláusula como:
			SELECT * FROM tabela WHERE coluna = 'Jhean Silva';
		e 'Jhean Silva' não existe na tabela, o banco de dados ainda usa o índice hash. Aqui está o passo a passo:
		
		1 - Cálculo do Hash:- Primeiro, o valor 'Jhean Silva' é passado pela função hash e transformado em uma chave hash específica, como AB123.

		2	- Acesso ao Local do Hash:- Com o índice hash, o banco de dados tenta acessar diretamente o local associado à chave AB123.

		3 - Verificação de Existência:- No local mapeado pelo hash, o banco de dados verifica se há algum registro correspondente ao valor 'Jhean Silva'.
			- Se houver um registro no local, ele é retornado.
			- Se não houver nenhum registro (local vazio):- O banco reconhece que 'Jhean Silva' não existe.
					- Isso elimina a necessidade de realizar uma varredura ou comparação completa na tabela.

# Normalização
	A normalização em banco de dados é um processo utilizado para organizar tabelas, eliminando redundâncias e inconsistências, e garantindo a integridade dos dados. Esse processo segue uma série de regras chamadas de formas normais, que ajudam a estruturar os dados de maneira eficiente.
	
	Aqui estão as principais formas normais:
		- Primeira Forma Normal (1FN): Garante que todos os atributos sejam atômicos (não divisíveis) e que não haja grupos repetidos em uma tabela.
		
		- Segunda Forma Normal (2FN): Além das regras da 1FN, elimina dependências parciais, ou seja, cada atributo não-chave deve depender totalmente da chave primária.
		
		- Terceira Forma Normal (3FN): Vai além da 2FN, eliminando dependências transitivas, onde atributos não-chave não devem depender de outros atributos não-chave.
		
		- Forma Normal de Boyce-Codd (BCNF): Uma versão mais rigorosa da 3FN, que resolve algumas anomalias específicas.
		
		- Quarta e Quinta Formas Normais (4FN e 5FN): Tratam de dependências multivaloradas e junções complexas, sendo menos comuns em projetos práticos.

	A normalização é essencial para evitar problemas como duplicação de dados e dificuldades de manutenção, tornando o banco de dados mais eficiente e fácil de gerenciar.
	
	# As anomalias em esquemas relacionais ocorrem quando a estrutura do banco de dados não está bem projetada, levando a problemas durante operações como inserção, exclusão e atualização de dados. Aqui estão os principais tipos de anomalias:

	- Anomalia de Inserção: Ocorre quando não é possível inserir dados em uma tabela sem que outras informações desnecessárias sejam adicionadas. Por exemplo, em uma tabela que combina informações de funcionários e projetos, pode ser impossível adicionar um novo projeto sem associá-lo a um funcionário.

	- Anomalia de Exclusão: Acontece quando a exclusão de um dado resulta na perda de informações importantes. Por exemplo, ao excluir um funcionário de uma tabela que também armazena informações sobre o departamento, pode-se perder os dados do departamento.

	- Anomalia de Atualização: Surge quando a atualização de um dado precisa ser feita em várias linhas, aumentando o risco de inconsistências. Por exemplo, se o endereço de um departamento estiver duplicado em várias linhas, a atualização de uma linha pode deixar as outras desatualizadas.

	Essas anomalias geralmente são resolvidas por meio da normalização, que organiza os dados em formas normais para evitar redundâncias e inconsistências.

	# Dependências funcionais são relações entre atributos em uma tabela de banco de dados, onde o valor de um atributo determina o valor de outro. Elas são fundamentais para o design de bancos de dados relacionais e para o processo de normalização.
	
	Por exemplo, se em uma tabela de funcionários o número do funcionário determina o nome, o salário e a cidade, podemos dizer que esses atributos dependem funcionalmente do número do funcionário. Isso é representado como Número do Funcionário → Nome, Salário, Cidade.
	
	Existem diferentes tipos de dependências funcionais:
		- Dependência Funcional Total: O atributo depende de toda a chave primária, especialmente em tabelas com chaves compostas.
		- Dependência Funcional Parcial: O atributo depende apenas de parte da chave primária composta.
		- Dependência Transitiva: Um atributo depende de outro que, por sua vez, depende de um terceiro.

	Essas dependências ajudam a identificar redundâncias e inconsistências, tornando o banco de dados mais eficiente e organizado. 

	# Um grafo mínimo de dependências funcionais é uma representação visual que mostra as relações entre atributos em um esquema de banco de dados, destacando as dependências funcionais essenciais. Ele ajuda a identificar redundâncias e inconsistências, facilitando o processo de normalização.
	No grafo:
		- Os nós representam os atributos.
		- As arestas indicam dependências funcionais, com o atributo determinante apontando para o atributo dependente.

	Por exemplo, se temos uma dependência funcional como CPF → Nome, o grafo mostraria uma seta do nó "CPF" para o nó "Nome". O objetivo é simplificar o grafo, removendo dependências redundantes ou transitivas, deixando apenas as relações fundamentais.

	# Exemplo de cenário:
		Suponha que temos uma tabela com os seguintes atributos:
		- CPF (chave primária)
		- Nome
		- Data de Nascimento
		- Endereço
		- Cidade
		- Estado

		E as dependências funcionais são:
		- CPF → Nome, Data de Nascimento, Endereço, Cidade, Estado
		- Cidade → Estado

		Etapas para criar o grafo mínimo:
		- Cada atributo será representado como um nó.
		- As dependências funcionais diretas serão representadas como setas. Por exemplo, CPF → Nome terá uma seta do nó "CPF" para o nó "Nome".
		- Removemos dependências transitivas. Por exemplo, se sabemos CPF → Cidade e Cidade → Estado, não precisamos representar CPF → Estado diretamente, pois é uma consequência transitiva.

		Grafo mínimo:
		- Nó Principal: CPF
		- Dependências diretas:
		- CPF → Nome
		- CPF → Data de Nascimento
		- CPF → Endereço
		- CPF → Cidade
		- Cidade → Estado

		Graficamente, ele pode ser descrito assim:
		CPF → Nome
		CPF → Data de Nascimento
		CPF → Endereço
		CPF → Cidade → Estado

	# A normalização por decomposição é uma técnica usada para melhorar o design de um banco de dados, dividindo tabelas maiores em tabelas menores e mais específicas, enquanto mantém a integridade dos dados. O objetivo principal é eliminar redundâncias, evitar anomalias (de inserção, exclusão e atualização) e garantir que o banco de dados esteja em uma forma normal adequada
	
	Como funciona a decomposição:
		- Identificação de dependências funcionais: Primeiro, analisamos as dependências funcionais entre os atributos da tabela.
		- Divisão em tabelas menores: Com base nas dependências, a tabela é dividida em tabelas menores, cada uma representando uma entidade ou relação específica.
		- Preservação da integridade: Garantimos que as tabelas resultantes possam ser unidas novamente (via operações de junção) para reconstruir os dados originais sem perda de informações.

	Exemplo prático:
		Imagine uma tabela Funcionários_Projetos com os seguintes atributos:
			- ID_Funcionário
			- Nome_Funcionário
			- ID_Projeto
			- Nome_Projeto

		Dependências funcionais
			- ID_Funcionário → Nome_Funcionário
			- ID_Projeto → Nome_Projeto

		Decomposição:
			- Tabela 1: Funcionários (ID_Funcionário, Nome_Funcionário)
			- Tabela 2: Projetos (ID_Projeto, Nome_Projeto)
			- Tabela 3: Funcionários_Projetos (ID_Funcionário, ID_Projeto)
	
		Essa decomposição elimina redundâncias, como a repetição do nome do funcionário ou do projeto em várias linhas.


# Transações em SQL são essencialmente um conjunto de operações que são realizadas como uma unidade única e indivisível de trabalho. Elas são extremamente úteis quando você precisa garantir que um conjunto de operações seja executado com sucesso, ou então nenhuma delas seja aplicada, mantendo a consistência dos dados no banco de dados. Em outras palavras, uma transação segue o princípio do "tudo ou nada".
Aqui estão os quatro princípios que regem as transações, conhecidos como propriedades ACID:
	- Atomicidade: Tudo ou nada. Se uma parte da transação falhar, tudo é desfeito.
	- Consistência: Garante que o banco de dados passe de um estado consistente para outro.
	- Isolamento: Transações independentes entre si, evitando interferências.
	- Durabilidade: Após ser concluída, a transação persiste, mesmo em caso de falha de sistema.

	# Uma transação em SQL pode ser implementada usando comandos específicos para garantir as propriedades ACID. Aqui está um exemplo prático para ilustrar:
	Imagine que você está lidando com uma transferência bancária, onde o dinheiro precisa ser debitado de uma conta e creditado em outra. Em SQL, o código poderia ser assim:
	Aqui está o que acontece:
		- BEGIN TRANSACTION: Inicia a transação. A partir daqui, todas as operações ficam "pendentes" até que sejam confirmadas ou revertidas.
		- UPDATE: Realiza as operações necessárias, como debitar e creditar valores em diferentes contas.
		- COMMIT: Finaliza a transação, confirmando que as mudanças devem ser aplicadas de forma permanente.

	Se algo der errado no meio do processo (por exemplo, uma falha no sistema ou um erro em uma das operações), você pode desfazer as alterações usando o comando ROLLBACK. Veja o exemplo:
	BEGIN TRANSACTION;
		-- Debitar da conta de origem
		UPDATE contas
		SET saldo = saldo - 100
		WHERE id_conta = 1;

		-- Simulando um erro (exemplo: saldo insuficiente na conta de destino)
		IF (SELECT saldo FROM contas WHERE id_conta = 2) < 100
		BEGIN
				ROLLBACK;
				PRINT 'Erro: Saldo insuficiente!';
				RETURN;
		END;

		-- Creditar na conta de destino
		UPDATE contas
		SET saldo = saldo + 100
		WHERE id_conta = 2;
	COMMIT;


# Locking em Acesso Concomitante de Transações" refere-se aos mecanismos usados para gerenciar o acesso simultâneo aos dados em um banco de dados, garantindo consistência e integridade durante transações concorrentes.
		
	Quando múltiplas transações ocorrem ao mesmo tempo, o locking (bloqueio) previne conflitos, como dois usuários tentando atualizar o mesmo registro simultaneamente. Existem diferentes tipos de locks, como:
	- Locks Compartilhados: Permitem que múltiplas transações leiam os mesmos dados, mas impedem modificações.
	- Locks Exclusivos: Garantem que apenas uma transação possa modificar os dados, bloqueando outras de ler ou escrever.
	- Locks de Atualização: Usados quando uma transação pretende modificar os dados, mas ainda não o fez.

	Esses locks são fundamentais para manter as propriedades ACID (Atomicidade, Consistência, Isolamento, Durabilidade) das transações. Por exemplo, se dois usuários tentarem comprar o último item em estoque ao mesmo tempo, o locking assegura que apenas uma transação tenha sucesso, evitando inconsistências.

# Leitura & Escrita de Item
	1. read_item(x)
	Este termo representa uma operação de leitura de um item específico em uma transação. Em outras palavras, read_item(x) refere-se ao ato de buscar ou acessar o valor atual de um item (como um dado ou registro no banco de dados). Após a execução, o valor de x é disponibilizado para ser usado na transação.
	Exemplo: Se você tem um sistema bancário e deseja verificar o saldo de uma conta antes de realizar uma operação, a transação usaria read_item(saldo) para acessar o valor atual do saldo.

	2. write_item(x)
	Este termo representa uma operação de escrita ou atualização de um item específico no banco de dados. O write_item(x) é usado quando uma transação modifica o valor de um item e salva essa alteração no banco de dados.
	Exemplo: No caso de uma transferência bancária, quando uma transação diminui o saldo de uma conta ou aumenta o saldo de outra, a transação executa write_item(saldo) para aplicar as mudanças.
	
	# Ciclo em uma transação:
		Em uma transação típica, primeiro ocorre uma operação de leitura (read_item(x)), seguida por algum tipo de processamento ou cálculo interno, e então, se necessário, uma operação de escrita (write_item(x)).
	
	# Controle de concorrência:
		Essas operações são fundamentais no controle de concorrência em transações, pois ajudam a determinar como os dados são acessados e modificados por várias transações simultâneas. Por exemplo:
			- read_item(x) pode bloquear um item para evitar que outro processo o modifique enquanto está sendo lido.
			- write_item(x) pode bloquear o item até que a transação seja confirmada ou revertida.

	Esses conceitos garantem que as propriedades ACID (Atomicidade, Consistência, Isolamento e Durabilidade) sejam mantidas durante o processamento de transações.

# O controle de concorrência em transações é essencial para manter a integridade e a consistência dos dados em um sistema de banco de dados quando múltiplas transações estão ocorrendo simultaneamente. Ele garante que as propriedades ACID (Atomicidade, Consistência, Isolamento e Durabilidade) sejam preservadas, mesmo em cenários de acesso concorrente.

	# Problemas que o controle de concorrência resolve:
		- Perda de Atualização (Lost Update):- Quando duas ou mais transações atualizam o mesmo dado simultaneamente, e as mudanças de uma transação sobrescrevem as de outra.

		- Leitura Suja (Dirty Read):- Quando uma transação lê dados que foram modificados, mas ainda não confirmados por outra transação, podendo gerar inconsistências se a outra transação for revertida.

		- Leitura Não Repetível (Non-Repeatable Read):- Quando uma transação lê o mesmo dado mais de uma vez, mas obtém valores diferentes porque outra transação modificou esse dado entre as leituras.

		- Fantasmas (Phantom Reads):- Quando uma transação executa uma consulta duas vezes, mas obtém conjuntos de resultados diferentes devido a inserções ou exclusões feitas por outra transação.

	# Técnicas de Controle de Concorrência:
		- Bloqueios (Locks):- Bloqueios Compartilhados (Shared Locks): Permitem que várias transações leiam um dado ao mesmo tempo, mas impedem modificações enquanto o bloqueio estiver ativo.
		- Bloqueios Exclusivos (Exclusive Locks): Permitem que apenas uma transação leia e modifique o dado, impedindo o acesso de outras transações.

		- Controle de Concorrência com Carimbo de Tempo (Timestamp):- Cada transação recebe um carimbo de tempo (timestamp) único e é executada com base em sua ordem de chegada. Transações mais antigas têm prioridade sobre as mais novas.

		- Controle Pessimista:- Assume que sempre haverá conflito, então bloqueios são aplicados preventivamente para evitar problemas.

		- Controle Otimista:- Assume que os conflitos são raros. As transações ocorrem sem bloqueios, mas há uma validação no momento do commit para garantir que não houve conflitos.

		- Serialização:- As transações são ordenadas de forma que o resultado final seja o mesmo que se as transações tivessem sido executadas uma de cada vez (serializadamente).

	# Ferramentas práticas em bancos de dados:
		A maioria dos sistemas de gerenciamento de bancos de dados (DBMS) modernos, como MySQL, PostgreSQL e SQL Server, oferecem suporte a níveis de isolamento para controlar concorrência:
			- READ UNCOMMITTED: Permite leitura de dados não confirmados (mais suscetível a problemas).
			- READ COMMITTED: Garante que apenas dados confirmados sejam lidos.
			- REPEATABLE READ: Garante que dados lidos por uma transação não sejam modificados até o final dela.
			- SERIALIZABLE: O nível mais restritivo, garantindo execução completamente isolada.

	# Ending transação
		- Ending the server
		- Instrução: alter table
		- Comando de start
		- Detecção de deadLock

	# Transação Concorrente:
		Ocorre quando duas ou mais transações estão simultaneamente tentando acessar ou modificar o mesmo registro no banco de dados. O MySQL utiliza mecanismos como bloqueios (locks) e níveis de isolamento para lidar com essas situações.
		- Identificação:
		O MySQL identifica uma transação concorrente se:- Ambas estão tentando executar write_item ou modificar o mesmo registro.
		- Uma transação tenta acessar um dado que está bloqueado por outra transação (por exemplo, em um bloqueio exclusivo).

		- Como o MySQL gerencia:- Utiliza locks (bloqueios compartilhados ou exclusivos) para controlar o acesso ao registro em questão. Exemplo:- Um bloqueio exclusivo impede que outra transação modifique o mesmo registro até o COMMIT ou ROLLBACK.

		- Depende do nível de isolamento configurado. Por exemplo, em SERIALIZABLE, transações concorrentes são completamente isoladas umas das outras.

		- Exemplo prático:- Transação 1: Atualiza o saldo da conta A (UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1).
		- Transação 2: Tenta ler ou modificar o saldo da mesma conta (SELECT saldo FROM contas WHERE id_conta = 1). Nesse caso, o MySQL detecta concorrência e aplica os bloqueios necessários para evitar conflitos.

	# Transação Sequencial:
		Ocorre quando duas ou mais transações estão operando em registros diferentes ou em momentos distintos, sem interferir diretamente uma na outra.
		- Identificação:
		O MySQL entende que transações são sequenciais quando:- Cada transação opera em registros completamente diferentes (não há conflito de acesso ao mesmo dado).
		- As transações são executadas uma após a outra, sem sobreposição no tempo.

		- Como o MySQL gerencia:- No caso de transações que não têm interdependência, o MySQL processa as operações normalmente, sem necessidade de bloqueios específicos.
		- Não há espera ou necessidade de gerenciamento especial, pois os dados acessados/modificados por cada transação não se sobrepõem.

		- Exemplo prático:- Transação 1: Atualiza o saldo da conta A (UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1).
		- Transação 2: Atualiza o saldo da conta B (UPDATE contas SET saldo = saldo - 50 WHERE id_conta = 2). Como essas transações operam em registros distintos, o MySQL não identifica concorrência e executa ambas normalmente.

	# Diferença entre as duas:
		- Concorrência: É marcada pela disputa pelo acesso ao mesmo recurso ou dado. O MySQL aplica mecanismos de controle para evitar inconsistências.
		- Sequencialidade: Representa transações que não interferem uma na outra, permitindo execução tranquila sem necessidade de bloqueios ou controles complexos.

	# Savepoint em transações é um recurso do SQL que permite definir pontos intermediários dentro de uma transação. Com o SAVEPOINT, você pode marcar um estado específico e, se necessário, reverter apenas parte da transação usando ROLLBACK TO SAVEPOINT, em vez de desfazer tudo com um ROLLBACK completo.
		Como funciona o SAVEPOINT?
			- Definir um ponto intermediário na transação:- Permite que partes específicas de uma transação sejam revertidas sem cancelar a transação inteira.

			- Fazer rollback até um SAVEPOINT específico:- Em caso de erro, você pode desfazer apenas até um determinado ponto, sem perder todas as alterações anteriores.

			- Excluir um SAVEPOINT:- Se um ponto intermediário não for mais necessário, ele pode ser removido com RELEASE SAVEPOINT.

		Benefícios do SAVEPOINT
			✅ Permite um controle mais refinado sobre reversão de transações.
			✅ Evita ROLLBACK completo, mantendo as operações anteriores intactas.
			✅ Útil para transações complexas, onde nem todas as operações precisam ser desfeitas em caso de erro.

	# Por que ocorre uma transação em espera no MySQL?
		Isso acontece em cenários de concorrência, quando duas ou mais transações tentam modificar ou ler o mesmo registro. Se uma transação já possui um bloqueio sobre esse recurso, outra transação que precise dele ficará em espera até que o bloqueio seja liberado.
	
	# Tipos de bloqueios que causam espera:
		- Bloqueio Exclusivo (Exclusive Lock)- Se uma transação já está modificando um registro com UPDATE ou DELETE, qualquer outra transação tentando modificar esse mesmo registro ficará esperando o primeiro commit ou rollback.

		- Bloqueio Compartilhado (Shared Lock)- Uma transação que está apenas lendo (SELECT ... FOR UPDATE) pode bloquear outras transações que tentam escrever no mesmo registro.

		- Deadlock (Impasse)- Se duas transações dependem de um recurso bloqueado pela outra, ocorre um deadlock, e MySQL escolhe uma das transações para ser cancelada.

	Exemplo prático de transação esperando no MySQL
		Suponha que duas transações tentam modificar o mesmo registro simultaneamente:
		Transação 1:
			START TRANSACTION;
			UPDATE contas SET saldo = saldo - 100 WHERE id_conta = 1;
			-- Transação 1 ainda não fez COMMIT

		Transação 2:
			START TRANSACTION;
			UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1;
			-- Fica em espera porque Transação 1 tem um bloqueio no registro!
	
		A Transação 2 não pode continuar até que a Transação 1 finalize com um COMMIT ou ROLLBACK.

	# Como resolver ou evitar espera em transações no MySQL?
		- Definir um tempo máximo de espera (innodb_lock_wait_timeout):
			SET innodb_lock_wait_timeout = 5; -- Tempo máximo de espera em segundos
			Assim, se uma transação ficar bloqueada por mais de 5 segundos, ela falha em vez de esperar indefinidamente.
		
		- Usar NOWAIT ou SKIP LOCKED para evitar bloqueio:
			NOWAIT: Se o recurso estiver bloqueado, a transação falha imediatamente, sem esperar
				SELECT * FROM contas WHERE id_conta = 1 FOR UPDATE NOWAIT;
			
			- SKIP LOCKED: Ignora registros bloqueados e continua a execução.
				SELECT * FROM contas WHERE id_conta = 1 FOR UPDATE SKIP LOCKED;

		- Evitar Deadlocks organizando a ordem das operações entre transações concorrentes.- Certifique-se de que todas as transações que envolvem múltiplos registros sigam sempre a mesma ordem para evitar dependências circulares.

		# Conclusão
			Transações em espera no MySQL ocorrem devido a bloqueios em registros sendo modificados por outras transações. Para evitar problemas, você pode ajustar tempos de espera (innodb_lock_wait_timeout), usar estratégias como NOWAIT ou SKIP LOCKED, e garantir que as transações sigam uma ordem lógica.





