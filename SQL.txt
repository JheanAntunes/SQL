SQL

- Modelagem de dados
- Constru√ß√£o de Banco de Dados
- Interpreta√ß√£o e Extra√ß√£o de Dados
- Desempenho
- Manuten√ß√£o dos M√©todos e procedures
- Equipe do DBA

=== Fundamentos do Banco de dados.
- Introduction a banco de dados.
- Sistemas de Gerenciamento de banco de dados.
- Modelagem de Dados para banco de dados.
- Arquitetura de banco de dados.

= Banco de dados
- Neg√≥cios
- E-commerce
- Medicina
- Engenharia
- Social Media
- Database --> Conjunto de dados.
`
Um banco de dados √© um sistema utilizado para armazenar, organizar e gerenciar grandes volumes de dados de maneira eficiente e estruturada..
`
- Contexto --> representa√ß√£o do mundo real
- Coer√™ncia;
- Prop√≥sito

================ SGBDs ======================
# SGBDs --> Sistemas de Gerenciamento de Banco de dado.

- Recupera√ß√£o de Dados: Gerencia a forma como os dados s√£o armazenados fisicamente e fornece mecanismos para recuper√°-los rapidamente.

- Controle de Acesso: Garante que apenas usu√°rios autorizados possam acessar e modificar os dados, proporcionando seguran√ßa e integridade.

- Integridade de Dados: Assegura que os dados armazenados est√£o corretos e consistentes.

- Suporte a Transa√ß√µes: Garante que opera√ß√µes de banco de dados, chamadas de transa√ß√µes, sejam realizadas completamente ou n√£o sejam realizadas de forma alguma, mantendo a consist√™ncia do banco de dados.

- Administra√ß√£o de Dados: Fornece ferramentas para monitorar e otimizar o desempenho do banco de dados.

# Modelo Relacional
- Tabelas: Estruturas que armazenam dados em linhas e colunas.

- Chaves Prim√°rias: Campos que identificam unicamente cada registro em uma tabela.

- Chaves Estrangeiras: Campos que criam relacionamentos entre tabelas, ligando um campo de uma tabela a um campo correspondente de outra tabela.

- Normaliza√ß√£o: Processo de organizar dados para reduzir a redund√¢ncia e melhorar a integridade dos dados.

- SQL (Structured Query Language): Linguagem padr√£o usada para gerenciar e consultar bancos de dados relacionais.

## SGBDs Mais utilizado no Mercado.
- Oracle
- MySQL
- SQLServer
- PostgreSQL
- MongoDB 
- Redis

## SGBDs Natureza auto-descritiva
- Descri√ß√£o da estrutura e constrains
- DB schema 

## SGBDs Isolamento e abstra√ß√£o.
- Abstra√ß√£o --> independ√™ncia do programa e dados
- Transpar√™ncia  

## M√∫ltiplas Vis√µes dos dados.
` Em um contexto de SGBDs relacionais, m√∫ltiplas vis√µes dos dados referem-se √† capacidade de visualizar dados de diferentes maneiras para atender a necessidades espec√≠ficas. Isso pode ser realizado atrav√©s de`

- Views (Vis√µes): Consultas SQL armazenadas que apresentam dados espec√≠ficos de uma ou mais tabelas sem alterar os dados subjacentes.

- √çndices: Estruturas que melhoram a efici√™ncia das consultas e permitem acesso r√°pido a registros.

- Consultas Personalizadas: SQL permite a cria√ß√£o de consultas personalizadas para extrair e visualizar dados conforme necess√°rio.

- Relat√≥rios Din√¢micos: Ferramentas que geram relat√≥rios com base em crit√©rios definidos pelo usu√°rio.


## Compartilhamento de Dados
- O compartilhamento de dados √© uma das principais fun√ß√µes dos SGBDs. Ele permite que diferentes usu√°rios e aplica√ß√µes acessem os mesmos dados sem conflitos. Algumas das caracter√≠sticas importantes do compartilhamento de dados incluem:

- Controle de Concurrency: T√©cnicas como bloqueios e controle de vers√µes s√£o usadas para garantir que m√∫ltiplas transa√ß√µes possam ocorrer simultaneamente sem interfer√™ncias indesejadas.

- Isolamento: Cada transa√ß√£o opera como se fosse a √∫nica em andamento, garantindo que as opera√ß√µes de uma transa√ß√£o n√£o afetem outras.

- Integridade dos Dados: Garantir que os dados permanecem corretos e consistentes durante opera√ß√µes simult√¢neas.

## Processamento de Transa√ß√µes Multiusu√°rios
- O processamento de transa√ß√µes √© fundamental para sistemas onde v√°rias opera√ß√µes de leitura e escrita ocorrem ao mesmo tempo. As caracter√≠sticas do processamento de transa√ß√µes multiusu√°rios incluem:

- ACID Properties: As transa√ß√µes devem seguir as propriedades de Atomicidade, Consist√™ncia, Isolamento e Durabilidade para garantir que sejam executadas corretamente.

- Recupera√ß√£o de Falhas: Capacidade de restaurar o sistema a um estado consistente ap√≥s falhas, como quedas de energia ou erros de software.

- Gerenciamento de Transa√ß√µes: Ferramentas e t√©cnicas para iniciar, gerenciar e encerrar transa√ß√µes de forma eficiente e segura.

# Abordagem de SGBDs - atores, Workers, Vantagens e quando n√£o utilizar

## Atores
- administrador
	- Gerencia Recursos
	- Orquestra√ß√£o
	- Autoriza√ß√£o de acesso
- Designers
	- identificar dados e requisitos
	- Representa√ß√£o e Estrutura
	- Fase preliminar
- usu√°rios Finais
	- Acesso --> SQL Querys {consultas}
	- Categorizadas
## Workers
- background
	- Designer do sistema de SGBD
	- Implementa√ß√£o do sistema de SGBD
		- Implementa√ß√£o
	- Pessoal de opera√ß√£o e manuten√ß√£o
	- Desenvolvedores de Ferramentas

============ Modelagem ===========

# Modelagem: √â o processo de criar uma representa√ß√£o simplificada de um sistema ou fen√¥meno do mundo real, com o objetivo de entender, analisar e comunicar suas caracter√≠sticas e comportamentos. Na engenharia de software, a modelagem √© usada para descrever a estrutura, o comportamento e os dados dos sistemas de software antes de serem desenvolvidos.

# Entidade: Em modelagem, uma entidade representa um objeto ou conceito do mundo real que possui um significado espec√≠fico no contexto do sistema que est√° sendo modelado. Por exemplo, em um sistema de gerenciamento de uma biblioteca, as entidades podem incluir "Livro", "Usu√°rio" e "Empr√©stimo". Cada entidade possui atributos que descrevem suas caracter√≠sticas, como t√≠tulo e autor para a entidade "Livro".

# UML (Unified Modeling Language): √â uma linguagem de modelagem visual padronizada usada para especificar, visualizar, construir e documentar os artefatos de um sistema de software. A UML fornece um conjunto de diagramas que ajudam a representar diferentes aspectos do sistema, como:

- Diagramas de caso de uso (Use Case Diagrams)

- Diagramas de classes (Class Diagrams)

- Diagramas de sequ√™ncia (Sequence Diagrams)

- Diagramas de atividades (Activity Diagrams)

A UML √© amplamente utilizada na engenharia de software para auxiliar na comunica√ß√£o entre os membros da equipe de desenvolvimento e na documenta√ß√£o do sistema.

========= Arquitetura BDs =============
# Modelo
	- abstra√ß√£o = essencial
		- data model
- classifica√ß√£o	
	- Estrutura
	- Modelo de dados conceitual
		- vis√£o de alto n√≠vel
			- Entidade
			- Atributos
			- Relacionamentos
	- Modelo de Dados de Implementa√ß√£o
		- Representacional
			- Modelo de dados relacional
				- Constrains 
				- linguagens SQL
				- Opera√ß√£o
			- Modelos Hier√°rquicos
	- Modelo de dados F√≠sicos
		- especialista
# Esquemas, Inst√¢ncias e State BDs

- Schema
	- Descri√ß√£o
		- diagramas
- Inst√¢ncia
	- dados persistidos

- State BDs
	- update
	- insert
	- delete

# Three-Schema
- Views
- Cat√°logo
- Isolamento data/program

# Classifica√ß√£o de SGBDs
- Modelo de dados
	- SQL
	- NoSql
- N de usu√°rio
- N de sites
- Custo
- Tipo de caminho de acesso

===== Metodologia Modelagem de Dados =====

# mini-world Closed
- Retornar falso para dados n√£o existente no contexto do dbs

# √Ålgebra Relacional

- Linguagem formal para consulta/extra√ß√£o de dados
- O predicado √© a parte da ora√ß√£o que cont√©m o verbo e que traz informa√ß√µes sobre o sujeito.
	- Crit√©rio
		- where
		- having
- Processo do dbs
	- Projeto Conceitual
		- Projeto L√≥gico 
			- Projeto F√≠sico 
				- Valida√ß√£o
					- Produ√ß√£o								- Manuten√ß√£o
# Como Implementar um BD

- Entender o contexto e requisitos

- Perfil...

- Processo Evolutivo ou gradual
	- Implementa√ß√£o
	- Modelo
	- Arquitetura
	- Funcionalidades

# Projeto Conceitual

- Linguagens de modelagem de dados
	- Gr√°ficas
	- Textuais
- Coletas de Dados
- An√°lise

# Projeto L√≥gico
- Modelo Conceitual
	- Estrutura
		- Organiza√ß√£o dos dados

==== Project Logic x f√≠sico
O projeto l√≥gico se concentra na estrutura dos dados, enquanto o projeto f√≠sico considera a performance, armazenamento e seguran√ßa.


== Modelo ER: Tipos de Entidades, Chaves e Atributos ===

- Modelo Conceitual
	- Entidades
	- Atributos
	- Relacionamentos

- Diagrama ER
	- Raras Modifica√ß√µes
	- Facilidade de manipular
	- Esquema ER do dbs

# Entidades

- Componente B√°sico
- Exist√™ncia independente
- Atributos

# Atributos ER

- Caracter√≠sticas/Descri√ß√£o das Entidade

- Atributos Relacionados as inst√¢ncias
	- At√¥micos x Composto
		- At√¥micos simples √∫nica propriedade
		- Compostos por propriedades (concatena√ß√£o)
	- Atributos multivalorados
	- Armazenados e derivados
	- Atributos Nulos
	- Atributos Complexos

# Entidade Fraca

- Depend√™ncia: Elas dependem de uma entidade forte para sua identifica√ß√£o.

- Relacionamento Identificador: H√° um relacionamento entre a entidade fraca e a entidade forte, chamado de relacionamento identificador.

- Chave Parcial: A entidade fraca possui uma chave parcial que, combinada com a chave prim√°ria da entidade forte, forma a chave prim√°ria composta.

# Relacionamento Grau

- Relacionamento Bin√°rios
	- Aluno (entidade)
	- Curso (entidade)
	- Matricula (relacionamento)

- Relacionamento Tern√°rio
	- Paciente (entidade)
	- M√©dico (entidade)
	- Hospital (entidade)
	- Tratamento (relacionamento)

- N√∫mero de Entidades: Relacionamentos bin√°rios envolvem duas entidades, enquanto relacionamentos tern√°rios envolvem tr√™s entidades.

- Complexidade: Relacionamentos tern√°rios s√£o mais complexos e podem representar intera√ß√µes mais detalhadas entre entidades, comparado com relacionamentos bin√°rios.

# Constraints - Cardinalidade

- Cardinalidade
A cardinalidade, no contexto de rela√ß√µes, refere-se ao n√∫mero de tuplas (linhas) em uma rela√ß√£o. Em outras palavras, √© o total de registros presentes na tabela.

Exemplo: Se a tabela "Funcion√°rios" tiver 5 registros (linhas), sua cardinalidade ser√° 5.

Al√©m disso, a cardinalidade tamb√©m √© usada para descrever rela√ß√µes entre tabelas em um banco de dados, como:

1:1 (um para um): Cada linha de uma tabela est√° associada a uma √∫nica linha de outra tabela.

1:N (um para muitos): Uma linha de uma tabela pode estar associada a v√°rias linhas de outra tabela.

N:M (muitos para muitos): V√°rias linhas de uma tabela podem estar associadas a v√°rias linhas de outra tabela.

# Entidade Fraca

- Tipos de Entidades
	- Fracas
		- Dependem de outra
	- Relacionamento ID (interligadas)
	- Fortes
		- Owner Entity Type

# Nota√ß√µes DER

- Entidades: Classes/Objetos --> Ret√¢ngulo
- Relacionamentos: Agrega√ß√µes --> losango
- Atributos: Propriedades elementares --> eclipse
- Weak: Entidades, relacionamentos
- Chave Parcial: Linha pontilhada
- Chave principal: linha continua
- Depend√™ncia de exist√™ncia: ||
- Atributo derivado
- Atributo composto
- Participa√ß√£o total
- Cardinalidade 
- Constraint estrutural
# Relacionamento N-√°rio
- Tern√°rio,..., N-√°rio
- Perspectiva diferente do bin√°rio


==== Modelagem de Dados com EER ====
- Modelo ER 1970
- EER: Novos Conceitos Sem√¢nticos
- Desenvolvidos fora da √°rea de BDs
- Digrama ERR

# Modelo Enhanced ER
- Superclasses
- Heran√ßa
- Subclasses
	- Depende do contexto do BD
	- Objeto distinto no BD
	- Heran√ßa de Superclasse
- Generaliza√ß√£o e Especializa√ß√£o
- Categoria ou Union Type
- Heran√ßa: Atributo e relacionamento

# Heran√ßa

"Princ√≠pio pr√≥prio √° programa√ß√£o orientada a objetos (POO) que permite criar uma nova classe a partir de uma j√° existente."

- Reutiliza√ß√£o de c√≥digo
- Especializa√ß√£o de classes
- Agregar atributos e m√©todos

# Especializa√ß√£o e Generaliza√ß√£o

- Generaliza√ß√£o: Combina m√∫ltiplas entidades espec√≠ficas em uma entidade gen√©rica (movimento de "baixo para cima").
- Exemplo: Entidades Carro e Caminh√£o podem ser generalizadas para Ve√≠culo.

- Especializa√ß√£o: Divide uma entidade gen√©rica em entidades mais espec√≠ficas (movimento de "cima para baixo").
- Exemplo: Ve√≠culo pode ser especializado em Carro e Caminh√£o.

# [1:1]
- inst√¢ncias das superclasse e subclasses
- Mesma representa√ß√£o de mundo real
- Papel especializado

# Diferen√ßa Fundamental:
A generaliza√ß√£o foca em encontrar semelhan√ßas e agrupar o que √© comum, enquanto a especializa√ß√£o foca em identificar diferen√ßas e detalhar o que √© √∫nico.

# Constraints - Modelo EER 
- Predicated-defined (condi√ß√£o)
	- Defini√ß√£o: Aqui, a divis√£o de um supertipo em subtipos 	√© feita com base em condi√ß√µes l√≥gicas ou predicados.
- Attribute-defined Specialization
	- Defini√ß√£o: A especializa√ß√£o ou generaliza√ß√£o √© guiada 	por valores espec√≠ficos de um atributo no supertipo.
- User-defined
	- Defini√ß√£o: Neste caso, n√£o h√° predicados ou atributos 	claramente definidos. A categoriza√ß√£o √© baseada na 	decis√£o manual do usu√°rio.

# Hier√°rquica & Rede de Especializa√ß√£o
- Hierarquia de especializa√ß√£o
- Rede de especializa√ß√£o

# Estrutura no Modelo

- Categoriza√ß√£o: N√£o altera a estrutura das entidades. Cada uma mant√©m seus atributos e relacionamentos. A categoriza√ß√£o √© mais como "etiquetas" ou identificadores.
- Exemplo: Na categoriza√ß√£o, voc√™ identifica Cliente VIP sem mudar a estrutura da tabela de Clientes.

- Union Types: Requer a cria√ß√£o de uma nova entidade que abstrai ou agrega entidades distintas. Isso pode alterar a forma como os relacionamentos e atributos s√£o modelados.
- Exemplo: Ao criar um Union Type como Usu√°rioBiblioteca, atributos ou relacionamentos comuns (como Data de Empr√©stimo) s√£o migrados para o tipo unificado.

# Terminologias

- Knowledge representation (KR)

- Ontologia

# Conceitos Modelo Relacional
- Modelo Relacional
	- Cole√ß√£o de Rela√ß√£o
		- Classes
		- Objetos
- Tabelas x Arquivos
- Entidade
- tabela --> Rela√ß√£o
- Tupla --> linha || inst√¢ncia || registro
- Atributo --> propriedade/Coluna da rela√ß√£o

# O que √© L√≥gica de Predicado?
A l√≥gica de predicado √© um ramo da l√≥gica matem√°tica que estuda proposi√ß√µes com vari√°veis e quantificadores, como "para todo" (‚àÄ) e "existe" (‚àÉ). Diferente da l√≥gica proposicional (que usa apenas proposi√ß√µes simples), a l√≥gica de predicado permite descrever rela√ß√µes entre objetos e suas propriedades de forma mais detalhada.
Por exemplo:
	- Proposi√ß√£o: "Maria √© uma estudante."
	
	- L√≥gica de Predicado: Estudante(Maria), onde "Estudante" √© um predicado que define uma propriedade da vari√°vel "Maria".
	
- Consultas SQL: A l√≥gica de predicado influencia a forma como as consultas s√£o formuladas. Um comando SQL, como SELECT, √© semelhante √† aplica√ß√£o de predicados para filtrar ou projetar os dados.


# Dom√≠nio
O dom√≠nio refere-se ao conjunto de valores poss√≠veis que um atributo pode assumir. √â como uma "regra" que define os valores v√°lidos para determinada coluna.

Exemplo: Se o atributo "Idade" tiver um dom√≠nio definido como n√∫meros inteiros entre 18 e 65, isso significa que somente valores dentro desse intervalo ser√£o aceitos para essa coluna.

O dom√≠nio garante que os dados armazenados sejam v√°lidos e consistentes com as restri√ß√µes aplicadas.

# Constraints Modelo Relacional

- Integridade dos Dados: Garantem que os dados sejam v√°lidos e consistentes com as regras do sistema.

- Preven√ß√£o de Erros: Evitam a entrada de dados inv√°lidos.

- Automatiza√ß√£o de Regras de Neg√≥cio: Muitas regras podem ser implementadas diretamente no design do banco de dados.

- DDL --> Data Definition Language --> Create, Drop, Insert, Rename
- DML --> Data Manipulation Language --> Insert, Update, Delete, Merge
- DCL --> Data Control Language --> Grant, Revoke
- DQL - Data Query Language --> Select

- Integridade Referencial: √â uma regra que mant√©m os relacionamentos entre tabelas consistentes, garantindo que n√£o haja refer√™ncias a dados inexistentes em tabelas relacionadas.

- Chave Estrangeira (Foreign Key): √â um campo em uma tabela que cria o v√≠nculo com a chave prim√°ria de outra tabela, assegurando a integridade referencial.

# Relacionamentos 1:1

geralmente existem duas op√ß√µes para o mapeamento relacional:
1. Unir as tabelas: Incorporar os atributos de uma entidade na tabela da outra.
2. Usar chaves estrangeiras: Cada entidade mant√©m sua tabela, e o relacionamento √© representado por uma chave estrangeira.
	1. Use a primeira abordagem quando o relacionamento √© altamente dependente e quase insepar√°vel.

	2.	A segunda abordagem √© preferida quando as entidades t√™m identidades pr√≥prias e podem existir separadamente.

# Um relacionamento bin√°rio 1:N 

(um para muitos) ocorre quando uma entidade A se associa a v√°rias entidades B, mas cada entidade B est√° associada a apenas uma entidade A.

1. Identificar as Entidades e o Relacionamento:
Exemplo: Entidade Cliente (1) e Pedido (N).

Um cliente pode fazer v√°rios pedidos, mas cada pedido est√° associado a um √∫nico cliente.

2. Definir o Relacionamento:
A tabela que representa o lado "muitos" (Pedidos) conter√° uma chave estrangeira que referencia a tabela do lado "um" (Clientes).

# Relacionamento N:M

Mapeamento de relacionamentos bin√°rios N:M (muitos para muitos) √© um conceito comum em modelagem de banco de dados relacional e an√°lise de sistemas. Ele representa uma associa√ß√£o onde m√∫ltiplas entidades de um lado podem estar relacionadas a m√∫ltiplas entidades do outro lado.

Esse modelo permite rastrear facilmente as associa√ß√µes entre as duas entidades e facilita a consulta ou manipula√ß√£o de dados. Posso detalhar mais, se precisar de algo espec√≠fico! üòä

=========== SQL ===========
- DDL --> Data Definition Language
	- Create | Drop | Alter
	- Insert | Update | Delete
	- Rename | Truncate | Merge
- User
- Schema
- Statementss
- INDEXING

# DDL (Data Definition Language)
Prop√≥sito: Definir e modificar a estrutura do banco de dados.

Comandos comuns:

CREATE: Cria novos objetos no banco de dados, como tabelas e √≠ndices.

ALTER: Modifica a estrutura de objetos existentes.

DROP: Remove objetos do banco.

TRUNCATE: Remove todos os registros de uma tabela, mantendo sua estrutura.

Foco: Gerencia a defini√ß√£o e organiza√ß√£o do banco de dados.

Reversibilidade: As altera√ß√µes geralmente n√£o podem ser revertidas (exemplo: ao usar DROP).

# DML (Data Manipulation Language)
Prop√≥sito: Manipular dados armazenados nas tabelas.

Comandos comuns:

SELECT: Recupera dados.

INSERT: Insere novos registros.

UPDATE: Atualiza registros existentes.

DELETE: Remove registros.

Foco: Lida com os dados propriamente ditos, sem modificar a estrutura das tabelas.

Reversibilidade: As altera√ß√µes realizadas podem ser desfeitas dentro de uma transa√ß√£o (usando ROLLBACK).

# DCL (Data Control Language)
Prop√≥sito: Gerenciar permiss√µes e seguran√ßa no banco de dados.

Comandos principais:

GRANT: Concede permiss√µes a usu√°rios ou pap√©is para acessar e realizar a√ß√µes no banco de dados.

Exemplo: GRANT SELECT, INSERT ON clientes TO usuarioX;

REVOKE: Revoga permiss√µes previamente concedidas.

Exemplo: REVOKE INSERT ON clientes FROM usuarioX;

Foco: Controlar quem pode acessar ou modificar os dados e as estruturas do banco.

# DQL (Data Query Language)
Prop√≥sito: Consultar dados do banco de dados.

Comando principal:

SELECT: √â a base do DQL e permite buscar dados de uma ou mais tabelas.

Exemplo: SELECT nome, email FROM clientes WHERE cidade = 'Rio de Janeiro';

Foco: Extrair e visualizar informa√ß√µes armazenadas no banco de dados.

# Constraints

PRIMARY KEY: Garante que cada registro de uma tabela seja √∫nico.

FOREIGN KEY: Estabelece uma rela√ß√£o entre duas tabelas, ligando uma chave de uma tabela √† chave prim√°ria de outra:

NOT NULL: Impede que uma coluna tenha valores nulos:

UNIQUE: Garante que todos os valores em uma coluna sejam √∫nicos:

CHECK: Define uma condi√ß√£o para os valores de uma coluna:

DEFAULT: Especifica um valor padr√£o para uma coluna, caso n√£o seja fornecido nenhum valor:

# Teoria por Tr√°s dos Alias
	Um alias √© simplesmente um nome alternativo, tempor√°rio e amig√°vel atribu√≠do a colunas ou tabelas dentro de uma consulta SQL. Ele serve para melhorar a legibilidade do c√≥digo ou facilitar a refer√™ncia a elementos complexos (como colunas calculadas ou subconsultas). Um alias n√£o altera os nomes reais no banco de dados, apenas os renomeia durante a execu√ß√£o da consulta.

Express√µes em SQL
	As express√µes s√£o usadas para realizar opera√ß√µes ou c√°lculos no SELECT. Elas podem incluir operadores aritm√©ticos, fun√ß√µes, concatena√ß√µes de strings e muito mais. Exemplos de express√µes comuns incluem:

	SELECT pre√ßo * quantidade AS total FROM vendas;

	SELECT nome || ' ' || sobrenome AS nome_completo FROM clientes;
	No exemplo acima, usamos || (em alguns bancos) para concatenar nome e sobrenome.

# LIKE
	O operador LIKE √© usado em consultas SQL para buscar padr√µes espec√≠ficos em colunas de texto. Ele funciona com curingas para tornar as buscas flex√≠veis:
	%: Representa zero ou mais caracteres.
¬¥¬¥
	SELECT * FROM clientes
	WHERE nome LIKE 'Jo%';
¬¥¬¥
	Isso vai retornar todos os clientes cujos nomes come√ßam com "Jo", como "Joana" ou "Jos√©".

# Outro exemplo:
	_: Representa um √∫nico caractere.
``
	SELECT * FROM produtos
	WHERE descricao LIKE '_ola';
``
	Isso busca algo como "bola", "cola", etc., j√° que o _ exige exatamente um caractere antes de "ola".

# BETWEEN
	O operador BETWEEN √© usado para buscar valores dentro de um intervalo. Ele funciona para tipos como n√∫meros, datas e at√© texto (seguindo a ordem alfab√©tica).
	- Exemplo com n√∫meros:
``
	SELECT * FROM vendas
	WHERE preco BETWEEN 50 AND 100;
``
	Isso retorna todas as vendas com pre√ßos entre 50 e 100, incluindo os limites.

# Exemplo com datas:
``
	SELECT * FROM pedidos
	WHERE data BETWEEN '2025-01-01' AND '2025-03-31';
``
	Aqui, voc√™ vai obter todos os pedidos feitos nesse trimestre.

# UNION
	O operador UNION combina os resultados de duas ou mais consultas, eliminando duplicatas por padr√£o. Os conjuntos devem ter o mesmo n√∫mero e tipo de colunas para funcionar.
``
	SELECT nome, email FROM clientes_brasil
	UNION
	SELECT nome, email FROM clientes_mexico;
``
	Esse comando retorna uma lista unificada de clientes do Brasil e do M√©xico, sem duplicatas.

# INTERSECT
	O operador INTERSECT retorna apenas as linhas que est√£o presentes em ambas as consultas.
``
	SELECT nome FROM clientes_brasil
	INTERSECT
	SELECT nome FROM clientes_mexico;
``
	Isso mostrar√° apenas os clientes que est√£o tanto na base do Brasil quanto na do M√©xico.

# EXCEPT
	O operador EXCEPT retorna as linhas que est√£o na primeira consulta, mas n√£o est√£o na segunda.
``
	SELECT nome FROM clientes_brasil
	EXCEPT
	SELECT nome FROM clientes_mexico;
``
	Isso listar√° os clientes que est√£o apenas no Brasil e n√£o no M√©xico.

Considera√ß√µes:
	Essas opera√ß√µes seguem a estrutura de colunas compat√≠veis (mesmo n√∫mero e tipo de colunas).

	A ordem das colunas e os nomes das tabelas podem importar para interpreta√ß√µes mais complexas.

	O suporte a INTERSECT e EXCEPT pode variar entre bancos de dados (alguns, como o MySQL, n√£o possuem nativamente, mas h√° alternativas).

Uma Nested Query (ou consulta aninhada)
	em SQL √© uma consulta dentro de outra consulta. A consulta interna (ou subconsulta) √© executada primeiro e o resultado √© usado pela consulta externa. Essas subconsultas s√£o geralmente usadas em instru√ß√µes SELECT, INSERT, UPDATE ou DELETE para realizar opera√ß√µes mais complexas ou filtragens.

A keyword IN em SQL 
	√© usada para especificar m√∫ltiplos valores em uma cl√°usula WHERE. √â uma maneira pr√°tica de verificar se um valor est√° dentro de uma lista de valores fornecidos, em vez de usar v√°rias condi√ß√µes combinadas com OR. Isso simplifica e torna as consultas mais leg√≠veis.

=== Cl√°usulas
	EXISTS: TRUE se o resultado da consulta aninhada contiver pelo menos uma tupla;

	NOT EXISTS: TRUE se o resultado da consulta aninhada n√£o contiver tuplas;

	UNIQUE: Retornar TRUE se √© √∫nico;

# SQL ORDER  BY
	A cl√°usula SQL ORDER BY √© usada para organizar os resultados de uma consulta em ordem ascendente (ASC) ou descendente (DESC), com base em uma ou mais colunas. Por padr√£o, a ordem √© crescente.

# Agrupamento de Registros;
	Agregar | Aglutinar | agrupar
	O GROUP BY √© uma cl√°usula no SQL usada para agrupar linhas que t√™m valores semelhantes em colunas espec√≠ficas. Ele √© muito √∫til para agregar dados e gerar resumos usando fun√ß√µes como COUNT(), SUM(), AVG(), MAX() e MIN().

==== Join ==== 
O que √© JOIN?
	O JOIN √© usado para combinar linhas de duas ou mais tabelas com base em uma condi√ß√£o l√≥gica.
	Geralmente, relacionamos tabelas usando uma chave prim√°ria de uma tabela e uma chave estrangeira de outra.

Tipos de JOIN:
	INNER JOIN (ou simplesmente JOIN): Retorna apenas as linhas que t√™m correspond√™ncia em ambas as tabelas.

	LEFT JOIN (ou LEFT OUTER JOIN): Retorna todas as linhas da tabela √† esquerda (A), mesmo que n√£o haja correspond√™ncia na tabela √† direita (B). Linhas sem correspond√™ncia em B ter√£o valores NULL.

	RIGHT JOIN (ou RIGHT OUTER JOIN): Retorna todas as linhas da tabela √† direita (B), mesmo que n√£o haja correspond√™ncia na tabela √† esquerda (A). Linhas sem correspond√™ncia em A ter√£o valores NULL.

	FULL JOIN (ou FULL OUTER JOIN): Retorna todas as linhas de ambas as tabelas. Linhas sem correspond√™ncia em uma das tabelas ter√£o valores NULL.

	CROSS JOIN: Retorna o produto cartesiano de ambas as tabelas (todas as combina√ß√µes poss√≠veis de linhas entre as tabelas).

	SELF JOIN: √â um JOIN de uma tabela com ela mesma. √ötil para comparar linhas dentro da mesma tabela.

# CASE WHEN THEN ELSE END
	A declara√ß√£o CASE √© usada para realizar condi√ß√µes dentro de uma consulta SQL e retornar valores baseados nessas condi√ß√µes. Ela √© parecida com um "if-else" em programa√ß√£o.
	Dicas:
	Voc√™ pode usar o CASE em praticamente qualquer lugar: em SELECT, WHERE, UPDATE, ORDER BY ou at√© mesmo HAVING.

	√â uma √≥tima maneira de criar categorias e personalizar os resultados dsa sua consulta.

# O que s√£o views?
	Uma view (ou vis√£o) √© essencialmente uma consulta armazenada no banco de dados, que pode ser tratada como uma tabela virtual. Essa tabela virtual n√£o armazena dados diretamente; em vez disso, ela exibe os dados provenientes de outras tabelas, baseando-se na consulta que a define. Pense nisso como uma "janela" para os dados, que facilita visualiza√ß√µes personalizadas e organizadas.

# Por que utilizar views?
	Aqui est√£o alguns motivos principais para utilizar views:
	
	1. Simplicidade: Elas podem simplificar consultas complexas. Por exemplo, se voc√™ tem uma consulta complicada que √© usada frequentemente, pode transform√°-la em uma view.
	
	2. Seguran√ßa: √â poss√≠vel restringir o acesso a determinados dados. Por exemplo, voc√™ pode criar uma view que s√≥ mostre certas colunas de uma tabela, ocultando outras.

	3. Manuten√ß√£o de dados: Ajuda a criar camadas de abstra√ß√£o. Se a estrutura das tabelas subjacentes mudar, basta ajustar a view, sem a necessidade de alterar as consultas em v√°rias partes do aplicativo.

	4. Reutiliza√ß√£o: Podem ser reutilizadas em diferentes partes do sistema, reduzindo redund√¢ncias no c√≥digo SQL.

# Restri√ß√µes e limita√ß√µes de views
	Apesar dos benef√≠cios, as views t√™m algumas restri√ß√µes e limita√ß√µes:

	1. Somente leitura: Algumas views podem ser somente leitura, especialmente se contiverem opera√ß√µes complexas como JOIN, agrega√ß√µes (SUM, AVG), ou DISTINCT.

	2. Performance: Como s√£o baseadas em consultas, o uso excessivo de views pode impactar o desempenho, especialmente em bancos com grande volume de dados.

	3. Atualiza√ß√µes: Nem todas as views podem ser atualizadas diretamente. Quando poss√≠vel, isso depende de como a view foi definida
	
	4. Depend√™ncia: Altera√ß√µes na estrutura das tabelas subjacentes podem exigir ajustes nas views  

# Atomicidade - ACID
	A atomicidade significa que uma transa√ß√£o no banco de dados deve ser tratada como uma unidade √∫nica e indivis√≠vel. Ou seja, ou todas as opera√ß√µes dentro de uma transa√ß√£o s√£o conclu√≠das com sucesso, ou nenhuma delas √© aplicada. Isso evita que dados sejam deixados em um estado inconsistente.

	Por exemplo, imagine que voc√™ est√° transferindo dinheiro de uma conta para outra:
	1. Debitar da Conta A.
	2. Creditar na Conta B
	
	Se ocorrer um erro depois de debitar a Conta A, mas antes de creditar na Conta B, a atomicidade garante que a transa√ß√£o ser√° revertida, mantendo as contas como estavam antes da opera√ß

# SQL Dinamico
	SQL din√¢mico √© uma t√©cnica utilizada para construir instru√ß√µes SQL de forma flex√≠vel e adapt√°vel. Ou seja, em vez de escrever consultas SQL est√°ticas, podemos criar scripts que geram essas consultas dinamicamente com base em vari√°veis ou condi√ß√µes espec√≠ficas. Isso √© especialmente √∫til quando precisamos adaptar a consulta de acordo com os dados fornecidos pelo usu√°rio ou requisitos espec√≠ficos do programa.
	
	# Por que usar SQL din√¢mico?
		Adaptabilidade: Permite construir consultas em tempo de execu√ß√£o.
		Flexibilidade: Ideal para cen√°rios onde n√£o sabemos antecipadamente a estrutura exata da consulta.
		Automatiza√ß√£o: Reduz a necessidade de criar m√∫ltiplas consultas est√°ticas para diferentes cen√°rios.
	
	Como funciona na pr√°tica? Vamos ao exemplo! Imagine que queremos consultar uma tabela chamada "Produtos" e filtrar os resultados com base em crit√©rios que s√≥ descobriremos na execu√ß√£o. O SQL din√¢mico pode ser criado assim:
	DECLARE @sql NVARCHAR(MAX);
	DECLARE @categoria NVARCHAR(50);

	SET @categoria = 'Eletr√¥nicos';

	SET @sql = 'SELECT * FROM Produtos WHERE Categoria = ''' + @categoria + '''';

	EXEC sp_executesql @sql;

	A vari√°vel @categoria armazena o filtro desejado
	A instru√ß√£o SQL √© concatenada usando a vari√°vel, criando uma consulta personalizada.
	sp_executesql executa o SQL din√¢mico gerado.

	# Cuidados ao usar SQL din√¢mico:
		Seguran√ßa: Evite vulnerabilidades de SQL Injection. Sempre valide os dados inseridos pelo usu√°rio
		
		Desempenho: Pode ser menos eficiente do que consultas est√°ticas. Use com modera√ß√£o.

		Legibilidade: Pode dificultar a manuten√ß√£o do c√≥digo, ent√£o documente bem.

# O que √© uma stored procedure?
	Uma stored procedure (ou "procedimento armazenado") √© basicamente um conjunto de comandos SQL que √© salvo no banco de dados e pode ser reutilizado sempre que necess√°rio. Pense nela como uma fun√ß√£o no mundo da programa√ß√£o: voc√™ escreve o c√≥digo uma vez, armazena no banco e pode cham√°-lo sempre que precisar executar aquela l√≥gica.
	
	# Por que usar stored procedures?
		- Reutiliza√ß√£o: Pode ser chamada v√°rias vezes sem precisar escrever o mesmo c√≥digo repetidamente.
		- Efici√™ncia: Reduz o tr√°fego entre a aplica√ß√£o e o banco de dados, j√° que o c√≥digo √© executado no servidor de banco.
		- Seguran√ßa: Pode controlar o acesso, permitindo que usu√°rios executem a procedure sem precisar visualizar diretamente os dados do banco
		- Manuten√ß√£o: Facilita as altera√ß√µes, pois voc√™ edita o c√≥digo em um √∫nico lugar.
	
	# Procedures Parametros
		IN (Par√¢metro de Entrada)
			- O que √©? √â usado para passar valores para a procedure.
			- Caracter√≠stica: Os valores do par√¢metro n√£o podem ser alterados dentro da procedure. Eles s√£o apenas lidos.
		
		OUT (Par√¢metro de Sa√≠da)
			- O que √©? √â usado para retornar valores da procedure para quem a chamou.
			- Caracter√≠stica: N√£o tem valor inicial; ele ser√° atribu√≠do dentro da procedure.

		INOUT (Par√¢metro de Entrada e Sa√≠da)
			- O que √©? √â usado para receber um valor como entrada e retornar um valor como sa√≠da.
			- Caracter√≠stica: Permite modificar o valor do par√¢metro dentro da procedure.

	# Exemplo de stored procedure:
		Vamos criar uma procedure que retorna os produtos de uma determinada categoria:
		CREATE PROCEDURE GetProdutosPorCategoria
    @Categoria NVARCHAR(50) -- variable
		AS
		BEGIN -- inicio
				SELECT * FROM Produtos
				WHERE Categoria = @Categoria;
		END; -- fim
	Como usar essa stored procedure?
	Depois de criar a procedure, podemos execut√°-la assim:
	EXEC GetProdutosPorCategoria @Categoria = 'Eletr√¥nicos';
	
	Vantagens adicionais:
		Ajuda a organizar melhor o c√≥digo SQL.
		√â √≥tima para cen√°rios onde h√° muita l√≥gica complexa.
	
	Cuidado:
		Como em qualquer outro recurso, use com sabedoria para evitar consultas que possam afetar o desempenho do banco.

# O Que √© Condition Handling?
	Quando algo d√° errado, como uma divis√£o por zero ou uma viola√ß√£o de restri√ß√£o, o MySQL gera uma condi√ß√£o. Para lidar com essas condi√ß√µes, usamos handlers dentro de Stored Procedures ou Triggers. Um Handler informa ao SQL como reagir a um erro ou aviso espec√≠fico
	
	# Estrutura B√°sica de um Handler
		Um handler √© configurado dentro de uma procedure com a seguinte estrutura:
		DECLARE tipo_do_handler HANDLER FOR condi√ß√£o_espec√≠fica 
    a√ß√£o_a_ser_executada;

		tipo_do_handler: Define como o handler funciona
			CONTINUE: Ignora o erro ou condi√ß√£o e prossegue para a pr√≥xima instru√ß√£o.
			EXIT Sai imediatamente da procedure ou bloco.
		
		condi√ß√£o_espec√≠fica: Define o tipo de condi√ß√£o que o handler captura, como:
			SQLEXCEPTION: Captura qualquer erro SQL.
			SQLWARNING: Captura alertas.
			NOT FOUND: Captura situa√ß√µes onde um resultado esperado n√£o foi encontrado.
	
	# Exemplo 1: Tratando SQLEXCEPTION com CONTINUE
		Imagine que queremos capturar erros e continuar a execu√ß√£o:
		DELIMITER $$
			CREATE PROCEDURE exemplo_handler()
			BEGIN
					DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
							SET @erro = 'Ocorreu um erro, mas estamos continuando!';
					
					-- Tentativa de divis√£o por zero (gera erro)
					SET @resultado = 10 / 0;

					-- O pr√≥ximo c√≥digo ser√° executado mesmo ap√≥s o erro
					SET @mensagem = 'Execu√ß√£o continuada ap√≥s o erro!';
					SELECT @mensagem;
			END $$
		DELIMITER ;

	# Exemplo 2: Tratando NOT FOUND com EXIT
		Este exemplo lida com situa√ß√µes em que nenhum dado √© encontrado, e encerra o bloco.
		DELIMITER $$
			CREATE PROCEDURE exemplo_not_found()
			BEGIN
					DECLARE EXIT HANDLER FOR NOT FOUND
							SET @mensagem = 'Nenhum dado encontrado!';
					
					-- Tentativa de buscar um dado inexistente
					SELECT nome INTO @resultado FROM usuarios WHERE id = -1;
					
					-- Se nenhum dado for encontrado, o handler ser√° acionado
					SELECT @mensagem;
			END $$
		DELIMITER ;
	Resultado: A execu√ß√£o termina com uma mensagem caso nenhum dado seja encontrado.

	# Por que Usar Condition Handling?
		- Robustez: Garante que o c√≥digo lide com problemas sem falhas graves.
		- Personaliza√ß√£o: Permite mostrar mensagens mais informativas.
		- Controle: D√° flexibilidade para decidir como proceder em diferentes situa√ß√µes.
	
	# 1. Objetivo e Uso
		Procedures (Procedimentos): S√£o usadas principalmente para executar a√ß√µes complexas e processos. Podem incluir m√∫ltiplas opera√ß√µes como inserir, atualizar ou consultar dados.
			Exemplo: Executar v√°rios c√°lculos, modificar tabelas ou interagir com m√∫ltiplos registros.
			Normalmente chamadas diretamente com CALL.
		
		Functions (Fun√ß√µes): S√£o usadas para retornar um √∫nico valor baseado em um c√°lculo ou opera√ß√£o. Geralmente utilizadas dentro de queries SQL:
			Exemplo: Retornar o total de vendas ou calcular impostos.
			Chamadas diretamente em express√µes SQL como SELECT minha_funcao().
	
	# 2. Forma de Chamada
		CALL minha_procedure(parametros);
		SELECT minha_funcao(parametros);
	
	# 3. Sa√≠da
		Procedures: Podem ter m√∫ltiplas sa√≠das, seja por meio de vari√°veis ou manipula√ß√£o de tabelas. Elas n√£o s√£o usadas diretamente dentro de queries.

		Functions: Devem retornar exatamente um valor (como n√∫meros, textos ou resultados calculados), sendo frequentemente usadas dentro de .
	
	# 4. Utiliza√ß√£o em Queries
		Procedures: N√£o podem ser usadas diretamente em queries SQL, apenas chamadas com CALL.
		
		Functions: Podem ser integradas em queries SQL.
			Exemplo:
				SELECT minha_funcao(parametros) AS resultado;
	
	# 5. Manipula√ß√£o de Dados
		Procedures: Podem modificar dados, incluindo inser√ß√µes, atualiza√ß√µes ou exclus√µes em tabelas.
		
		Functions: N√£o devem modificar dados diretamente; s√£o limitadas ao c√°lculo e retorno de valores.

# Assertions no MySQL:
	CHECK constraints: O MySQL n√£o oferece suporte direto a essa funcionalidade, comum em outros bancos de dados.

	Alternativas: Verifica√ß√µes podem ser simuladas com triggers ou atrav√©s da l√≥gica no seu aplicativo.

# Implementa√ß√£o com Triggers:
	Triggers permitem executar a√ß√µes antes ou depois de eventos como inser√ß√µes ou atualiza√ß√µes.

	Exemplo: Validar se a idade √© maior ou igual a 18 antes de inserir na tabela pessoas;
	CREATE TRIGGER valida_idade_insere 
		BEFORE INSERT ON pessoas 
		FOR EACH ROW 
		BEGIN
				IF NEW.idade < 18 THEN
						INSERT INTO mensagens_erro (mensagem) VALUES ('Idade deve ser maior ou igual a 18.');
						SIGNAL SQLSTATE '45000'
						SET MESSAGE_TEXT = 'Erro de valida√ß√£o no trigger.';
				END IF;
		END;

# Principais cen√°rios em que √© ideal usar triggers:
	1. Garantia de Integridade dos Dados
		Quando voc√™ quer assegurar que regras espec√≠ficas de neg√≥cios ou restri√ß√µes sejam aplicadas automaticamente.

		Exemplo: Validar que a idade de um usu√°rio seja maior ou igual a 18 antes de inserir o registro.

	2. Auditoria de Dados (Hist√≥rico)
		Para rastrear altera√ß√µes ou eventos no banco de dados sem necessidade de interven√ß√£o manual.
		
		Exemplo: Registrar em uma tabela de logs quem alterou um registro ou o hor√°rio da altera√ß√£o.
				CREATE TRIGGER log_alteracao
				AFTER UPDATE ON usuarios
				FOR EACH ROW
				INSERT INTO logs (usuario_id, data_alteracao)
				VALUES (OLD.id, NOW());
	
	3. Automa√ß√£o de Tarefas Repetitivas
		Executar a√ß√µes automaticamente, como atualizar um status ou calcular valores derivados.
	
		Exemplo: Atualizar o estoque automaticamente quando um pedido √© registrado.
	
	4. Aplica√ß√£o de Regras de Neg√≥cio
		Quando algumas regras precisam ser refor√ßadas automaticamente no banco.

		Exemplo: Evitar que valores negativos sejam inseridos em uma coluna de saldo.
	
	5. Consist√™ncia entre Tabelas
		Garantir consist√™ncia ou sincroniza√ß√£o de dados entre tabelas relacionadas.

		Exemplo: Excluir registros associados em uma tabela filha quando o registro correspondente na tabela pai √© deletado (emular ON DELETE CASCADE).

# Cuidados ao Usar Triggers:
	1. Desempenho: Triggers podem impactar o desempenho se n√£o forem bem projetados, especialmente em tabelas com grande volume de dados.

	2. Complexidade: Evite l√≥gica muito complexa em triggers, pois isso pode tornar a manuten√ß√£o do banco de dados mais dif√≠cil.

	3. Debugging: Localizar problemas em triggers pode ser desafiador, j√° que eles s√£o executados automaticamente nos bastidores.

# √çndices em MySQL
	Quando voc√™ declara uma primary key, o sistema automaticamente cria um √≠ndice para otimizar a busca e manipula√ß√£o dos dados. Mas o que exatamente √© um √≠ndice?
	Um √≠ndice √© uma estrutura de dados utilizada para localizar registros em uma tabela de maneira eficiente. Em MySQL, os √≠ndices geralmente utilizam a estrutura de dados B+ tree (√°rvore B+), que organiza os valores de forma hier√°rquica, facilitando buscas r√°pidas.

	Na mem√≥ria, um √≠ndice armazena dois principais componentes:
		1. Campo de indexa√ß√£o: Este √© o valor utilizado para ordenar e identificar os registros.

		2. Ponteiro: Um endere√ßo que aponta para a localiza√ß√£o f√≠sica do registro no armazenamento (disco), onde os dados reais est√£o salvos

	Dessa forma, o √≠ndice atua como um mapa, agilizando as opera√ß√µes de busca, inser√ß√£o e atualiza√ß√£o ao reduzir a necessidade de varrer toda a tabela.

	# Como o MySQL Trabalha com √çndices?
		Quando voc√™ cria um √≠ndice n√£o-clustered, como idx_nome, o MySQL armazena o √≠ndice como uma estrutura de dados separada (geralmente uma √°rvore B+) que cont√©m:
			1. Os valores indexados da coluna (nome, no caso do √≠ndice idx_nome).
			2. Ponteiros para os registros reais na tabela. Esses ponteiros podem ser:
				Para o √≠ndice clustered (em tabelas InnoDB), onde os dados reais est√£o armazenados.
				Para o local no disco (em tabelas MyISAM).
	
		# Por Que Isso √© R√°pido?
			Estrutura de √Årvore B+:
				Tanto o √≠ndice n√£o-clustered quanto o √≠ndice clustered s√£o armazenados como √°rvores B+. Essas √°rvores permitem acesso em tempo logar√≠tmico 
				
				(O(log n)), o que significa que mesmo para tabelas muito grandes, o n√∫mero de opera√ß√µes de busca √© pequeno.
				
				Exemplo: Se voc√™ tiver 1 milh√£o de registros, a √°rvore B+ talvez precise de apenas 20 verifica√ß√µes para encontrar o valor.
		
		# Nenhum Percorrimento Linha a Linha:
			Gra√ßas √† estrutura de √≠ndice ordenado, o MySQL n√£o precisa fazer uma varredura completa na tabela (full table scan).
			
			Ele vai diretamente ao registro desejado utilizando os √≠ndices e os ponteiros.
		
		# Como Isso Funciona na Pr√°tica
			Vamos ilustrar como o √≠ndice idx_nome trabalha:
			O √≠ndice idx_nome cont√©m algo assim:
				"Ana Costa" ‚Üí Ponteiro para o √≠ndice clustered
				"Carlos Mendes" ‚Üí Ponteiro para o √≠ndice clustered
				"Jhean Silva" ‚Üí Ponteiro para o √≠ndice clustered
				"Mariana Oliveira" ‚Üí Ponteiro para o √≠ndice clustered
			
			Ao buscar 'Jhean Silva':
				O MySQL localiza 'Jhean Silva' no √≠ndice idx_nome usando busca eficiente na √°rvore B+.
				Depois, o ponteiro leva diretamente ao √≠ndice clustered.

			No √≠ndice clustered, o MySQL acessa o registro completo, como
				id: 1, nome: 'Jhean Silva', email: 'jhean@gmail.com', cidade: 'Rio de Janeiro'
				
	# Tipos de √çndices no MySQL
		1. Primary Key: √â um √≠ndice √∫nico que identifica cada linha da tabela. Sempre √© criado automaticamente quando voc√™ define a chave prim√°ria de uma tabela.
	
		2. Unique Index: Garante que todos os valores no campo sejam √∫nicos.

		3. Index Normal: Um √≠ndice padr√£o que acelera as buscas, mas permite valores duplicados.

		4. Full-Text Index: Usado para pesquisas de texto, ideal para campos que cont√™m grandes blocos de texto, como artigos ou descri√ß√µes

		5. Spatial Index: Usado para dados geoespaciais (no tipo de dado geometry).

	# Como Criar um √çndice?
		Voc√™ pode criar √≠ndices ao definir a tabela ou posteriormente. Veja os exemplos
		Ao criar uma tabela:
		CREATE TABLE funcionarios (
			id INT AUTO_INCREMENT PRIMARY KEY,
			nome VARCHAR(50),
			salario DECIMAL(10,2),
			INDEX (nome)
		);
	
		Ap√≥s criar uma tabela:
			CREATE INDEX idx_nome ON funcionarios(nome);

Os √≠ndices hash s√£o uma t√©cnica de indexa√ß√£o que utiliza fun√ß√µes de hash para mapear os valores de uma coluna diretamente para um local espec√≠fico na tabela. Eles s√£o extremamente r√°pidos para buscas exatas (ou seja, quando voc√™ busca por um valor exato em uma coluna), mas possuem limita√ß√µes que precisam ser compreendidas para serem usados de forma eficiente.
	
	# Como Funciona um √çndice Hash?
		1 - Fun√ß√£o de Hash:
			A fun√ß√£o de hash pega o valor da coluna e gera um c√≥digo ou chave √∫nica chamado "hash". Por exemplo, o valor 'Jhean Silva' pode ser transformado em algo como AB123.

	2 - Mapa de Hash: 
		O banco de dados utiliza esse c√≥digo para localizar diretamente o registro correspondente na tabela. √â como usar um endere√ßo √∫nico para acessar a linha desejada, sem precisar percorrer outros registros.

	3 - Processo de Busca:- Quando voc√™ faz uma consulta como 
		WHERE nome = 'Jhean Silva', o √≠ndice hash transforma 'Jhean Silva' na chave AB123 e acessa diretamente o local do dado. Isso elimina a necessidade de varreduras ou buscas sequenciais.

	#Vantagens dos √çndices Hash
		1. Velocidade em Buscas Exatas:
			√≠ndices hash s√£o extremamente r√°pidos em consultas que usam igualdade (=). Por exemplo:
				SELECT * FROM clientes WHERE nome = 'Jhean Silva';

		2. Menor Overhead:
			Consomem menos espa√ßo do que outros tipos de √≠ndices, como os baseados em √°rvores B+.

		3. Simples e Diretos:
			S√£o mais simples de implementar e gerenciar, j√° que lidam com um √∫nico mapeamento de valor para chave.

	# Desvantagens dos √çndices Hash
		1. Inadequado para Consultas em Intervalo
			N√£o funcionam bem em consultas como:
				SELECT * FROM clientes WHERE id BETWEEN 10 AND 20;
			Isso ocorre porque os √≠ndices hash n√£o preservam a ordem dos valores.

		2. Colis√µes de Hash:
			Em casos raros, dois valores diferentes podem gerar o mesmo c√≥digo de hash (colis√£o). O banco de dados precisa lidar com essas colis√µes, o que pode reduzir a efici√™ncia

		3. Incompat√≠vel com LIKE ou ORDER BY:
			Consultas que usam LIKE '%Silva%' ou ordena√ß√£o n√£o se beneficiam de √≠ndices hash.

		4. Dependente da Fun√ß√£o de Hash:
			A efici√™ncia depende diretamente da qualidade da fun√ß√£o de hash utilizada pelo sistema.

	# Exemplo Pr√°tico
		Embora o MySQL n√£o utilize √≠ndices hash diretamente para tabelas InnoDB (que preferem √°rvores B+), voc√™ pode encontr√°-los em outros sistemas, como o mecanismo de armazenamento Memory Engine no MySQL.

		# Cria√ß√£o de √çndice Hash no MySQL:
			CREATE TABLE clientes (
				id INT PRIMARY KEY,
				nome VARCHAR(50),
				email VARCHAR(100),
				cidade VARCHAR(50)
			) ENGINE=MEMORY;
		CREATE INDEX idx_nome_hash ON clientes(nome) USING HASH;
			Busca Exata:
				SELECT * FROM clientes WHERE nome = 'Jhean Silva';
			Nesse caso, o √≠ndice hash ser√° usado para localizar 'Jhean Silva' de forma extremamente r√°pida.

	# Quando Usar √çndices Hash?
		√çndices hash s√£o ideais para:
			- Consultas que exigem igualdade exata (=).
			- Colunas com valores √∫nicos ou baixa cardinalidade (como identificadores ou status simples).
		Eles n√£o s√£o recomendados para:
			- Consultas em intervalos (BETWEEN, <, >) ou ordenadas (ORDER BY).
			- Situa√ß√µes que exigem ordena√ß√£o ou busca textual (LIKE).
	
	# Estrutura dos √çndices Hash
		Os √≠ndices hash n√£o possuem ponteiros convencionais como √≠ndices n√£o-clustered, mas em vez disso, utilizam diretamente uma fun√ß√£o de hash para mapear valores da coluna a um local espec√≠fico onde o registro correspondente pode ser acessado. Vamos explorar os conceitos envolvidos:
	
	# Busca Bin√°ria vs. Fun√ß√£o de Hash
		1. Fun√ß√£o de Hash
			- A fun√ß√£o de hash transforma o valor em uma "chave hash". Essa chave serve como um identificador √∫nico que corresponde diretamente a um espa√ßo ou local onde o dado √© armazenado.

			- N√£o √© necess√°rio realizar uma busca bin√°ria para encontrar o hash, porque o c√°lculo do hash √© feito diretamente pelo algoritmo. O processo √© instant√¢neo: dado o valor de entrada, a fun√ß√£o gera o hash.

		2. Localiza√ß√£o do Dado no Disco:
			- Uma vez que o valor √© convertido em um hash, o √≠ndice hash mapeia diretamente para o local onde os dados est√£o armazenados. O banco de dados acessa o registro correspondente no disco ou na mem√≥ria usando essa chave hash.

	# O Fluxo de Busca com √çndices Hash
		Aqui est√° como funciona a busca com √≠ndices hash:
			
			1. Entrada: Quando voc√™ faz uma consulta como WHERE nome = 'Jhean Silva', o banco de dados aplica a fun√ß√£o de hash para calcular o c√≥digo hash de 'Jhean Silva'.
			
			2. Hash como Endere√ßo: O c√≥digo hash gerado √© usado para acessar diretamente o bloco de mem√≥ria ou disco que cont√©m o registro desejado.
			
			3. Dado Real: Finalmente, o registro completo √© lido e retornado na resposta da consulta.

	# Por Que √çndices Hash N√£o Fazem Busca Bin√°ria?
		A busca bin√°ria √© usada em estruturas ordenadas, como √°rvores B+. No caso dos √≠ndices hash:
			- O dado n√£o est√° ordenado; ele √© mapeado diretamente por uma fun√ß√£o de hash.
			
			- A efici√™ncia da busca vem do fato de que o hash atua como uma refer√™ncia direta ao local do registro.
	O processo elimina a necessidade de percorrer ou comparar valores, tornando os √≠ndices hash ideais para buscas exatas.

	# Como o √çndice Hash Lida com Valores que N√£o Existem
		Quando voc√™ usa uma cl√°usula como:
			SELECT * FROM tabela WHERE coluna = 'Jhean Silva';
		e 'Jhean Silva' n√£o existe na tabela, o banco de dados ainda usa o √≠ndice hash. Aqui est√° o passo a passo:
		
		1 - C√°lculo do Hash:- Primeiro, o valor 'Jhean Silva' √© passado pela fun√ß√£o hash e transformado em uma chave hash espec√≠fica, como AB123.

		2	- Acesso ao Local do Hash:- Com o √≠ndice hash, o banco de dados tenta acessar diretamente o local associado √† chave AB123.

		3 - Verifica√ß√£o de Exist√™ncia:- No local mapeado pelo hash, o banco de dados verifica se h√° algum registro correspondente ao valor 'Jhean Silva'.
			- Se houver um registro no local, ele √© retornado.
			- Se n√£o houver nenhum registro (local vazio):- O banco reconhece que 'Jhean Silva' n√£o existe.
					- Isso elimina a necessidade de realizar uma varredura ou compara√ß√£o completa na tabela.

# Normaliza√ß√£o
	A normaliza√ß√£o em banco de dados √© um processo utilizado para organizar tabelas, eliminando redund√¢ncias e inconsist√™ncias, e garantindo a integridade dos dados. Esse processo segue uma s√©rie de regras chamadas de formas normais, que ajudam a estruturar os dados de maneira eficiente.
	
	Aqui est√£o as principais formas normais:
		- Primeira Forma Normal (1FN): Garante que todos os atributos sejam at√¥micos (n√£o divis√≠veis) e que n√£o haja grupos repetidos em uma tabela.
		
		- Segunda Forma Normal (2FN): Al√©m das regras da 1FN, elimina depend√™ncias parciais, ou seja, cada atributo n√£o-chave deve depender totalmente da chave prim√°ria.
		
		- Terceira Forma Normal (3FN): Vai al√©m da 2FN, eliminando depend√™ncias transitivas, onde atributos n√£o-chave n√£o devem depender de outros atributos n√£o-chave.
		
		- Forma Normal de Boyce-Codd (BCNF): Uma vers√£o mais rigorosa da 3FN, que resolve algumas anomalias espec√≠ficas.
		
		- Quarta e Quinta Formas Normais (4FN e 5FN): Tratam de depend√™ncias multivaloradas e jun√ß√µes complexas, sendo menos comuns em projetos pr√°ticos.

	A normaliza√ß√£o √© essencial para evitar problemas como duplica√ß√£o de dados e dificuldades de manuten√ß√£o, tornando o banco de dados mais eficiente e f√°cil de gerenciar.
	
	# As anomalias em esquemas relacionais ocorrem quando a estrutura do banco de dados n√£o est√° bem projetada, levando a problemas durante opera√ß√µes como inser√ß√£o, exclus√£o e atualiza√ß√£o de dados. Aqui est√£o os principais tipos de anomalias:

	- Anomalia de Inser√ß√£o: Ocorre quando n√£o √© poss√≠vel inserir dados em uma tabela sem que outras informa√ß√µes desnecess√°rias sejam adicionadas. Por exemplo, em uma tabela que combina informa√ß√µes de funcion√°rios e projetos, pode ser imposs√≠vel adicionar um novo projeto sem associ√°-lo a um funcion√°rio.

	- Anomalia de Exclus√£o: Acontece quando a exclus√£o de um dado resulta na perda de informa√ß√µes importantes. Por exemplo, ao excluir um funcion√°rio de uma tabela que tamb√©m armazena informa√ß√µes sobre o departamento, pode-se perder os dados do departamento.

	- Anomalia de Atualiza√ß√£o: Surge quando a atualiza√ß√£o de um dado precisa ser feita em v√°rias linhas, aumentando o risco de inconsist√™ncias. Por exemplo, se o endere√ßo de um departamento estiver duplicado em v√°rias linhas, a atualiza√ß√£o de uma linha pode deixar as outras desatualizadas.

	Essas anomalias geralmente s√£o resolvidas por meio da normaliza√ß√£o, que organiza os dados em formas normais para evitar redund√¢ncias e inconsist√™ncias.

	# Depend√™ncias funcionais s√£o rela√ß√µes entre atributos em uma tabela de banco de dados, onde o valor de um atributo determina o valor de outro. Elas s√£o fundamentais para o design de bancos de dados relacionais e para o processo de normaliza√ß√£o.
	
	Por exemplo, se em uma tabela de funcion√°rios o n√∫mero do funcion√°rio determina o nome, o sal√°rio e a cidade, podemos dizer que esses atributos dependem funcionalmente do n√∫mero do funcion√°rio. Isso √© representado como N√∫mero do Funcion√°rio ‚Üí Nome, Sal√°rio, Cidade.
	
	Existem diferentes tipos de depend√™ncias funcionais:
		- Depend√™ncia Funcional Total: O atributo depende de toda a chave prim√°ria, especialmente em tabelas com chaves compostas.
		- Depend√™ncia Funcional Parcial: O atributo depende apenas de parte da chave prim√°ria composta.
		- Depend√™ncia Transitiva: Um atributo depende de outro que, por sua vez, depende de um terceiro.

	Essas depend√™ncias ajudam a identificar redund√¢ncias e inconsist√™ncias, tornando o banco de dados mais eficiente e organizado. 

	# Um grafo m√≠nimo de depend√™ncias funcionais √© uma representa√ß√£o visual que mostra as rela√ß√µes entre atributos em um esquema de banco de dados, destacando as depend√™ncias funcionais essenciais. Ele ajuda a identificar redund√¢ncias e inconsist√™ncias, facilitando o processo de normaliza√ß√£o.
	No grafo:
		- Os n√≥s representam os atributos.
		- As arestas indicam depend√™ncias funcionais, com o atributo determinante apontando para o atributo dependente.

	Por exemplo, se temos uma depend√™ncia funcional como CPF ‚Üí Nome, o grafo mostraria uma seta do n√≥ "CPF" para o n√≥ "Nome". O objetivo √© simplificar o grafo, removendo depend√™ncias redundantes ou transitivas, deixando apenas as rela√ß√µes fundamentais.

	# Exemplo de cen√°rio:
		Suponha que temos uma tabela com os seguintes atributos:
		- CPF (chave prim√°ria)
		- Nome
		- Data de Nascimento
		- Endere√ßo
		- Cidade
		- Estado

		E as depend√™ncias funcionais s√£o:
		- CPF ‚Üí Nome, Data de Nascimento, Endere√ßo, Cidade, Estado
		- Cidade ‚Üí Estado

		Etapas para criar o grafo m√≠nimo:
		- Cada atributo ser√° representado como um n√≥.
		- As depend√™ncias funcionais diretas ser√£o representadas como setas. Por exemplo, CPF ‚Üí Nome ter√° uma seta do n√≥ "CPF" para o n√≥ "Nome".
		- Removemos depend√™ncias transitivas. Por exemplo, se sabemos CPF ‚Üí Cidade e Cidade ‚Üí Estado, n√£o precisamos representar CPF ‚Üí Estado diretamente, pois √© uma consequ√™ncia transitiva.

		Grafo m√≠nimo:
		- N√≥ Principal: CPF
		- Depend√™ncias diretas:
		- CPF ‚Üí Nome
		- CPF ‚Üí Data de Nascimento
		- CPF ‚Üí Endere√ßo
		- CPF ‚Üí Cidade
		- Cidade ‚Üí Estado

		Graficamente, ele pode ser descrito assim:
		CPF ‚Üí Nome
		CPF ‚Üí Data de Nascimento
		CPF ‚Üí Endere√ßo
		CPF ‚Üí Cidade ‚Üí Estado

	# A normaliza√ß√£o por decomposi√ß√£o √© uma t√©cnica usada para melhorar o design de um banco de dados, dividindo tabelas maiores em tabelas menores e mais espec√≠ficas, enquanto mant√©m a integridade dos dados. O objetivo principal √© eliminar redund√¢ncias, evitar anomalias (de inser√ß√£o, exclus√£o e atualiza√ß√£o) e garantir que o banco de dados esteja em uma forma normal adequada
	
	Como funciona a decomposi√ß√£o:
		- Identifica√ß√£o de depend√™ncias funcionais: Primeiro, analisamos as depend√™ncias funcionais entre os atributos da tabela.
		- Divis√£o em tabelas menores: Com base nas depend√™ncias, a tabela √© dividida em tabelas menores, cada uma representando uma entidade ou rela√ß√£o espec√≠fica.
		- Preserva√ß√£o da integridade: Garantimos que as tabelas resultantes possam ser unidas novamente (via opera√ß√µes de jun√ß√£o) para reconstruir os dados originais sem perda de informa√ß√µes.

	Exemplo pr√°tico:
		Imagine uma tabela Funcion√°rios_Projetos com os seguintes atributos:
			- ID_Funcion√°rio
			- Nome_Funcion√°rio
			- ID_Projeto
			- Nome_Projeto

		Depend√™ncias funcionais
			- ID_Funcion√°rio ‚Üí Nome_Funcion√°rio
			- ID_Projeto ‚Üí Nome_Projeto

		Decomposi√ß√£o:
			- Tabela 1: Funcion√°rios (ID_Funcion√°rio, Nome_Funcion√°rio)
			- Tabela 2: Projetos (ID_Projeto, Nome_Projeto)
			- Tabela 3: Funcion√°rios_Projetos (ID_Funcion√°rio, ID_Projeto)
	
		Essa decomposi√ß√£o elimina redund√¢ncias, como a repeti√ß√£o do nome do funcion√°rio ou do projeto em v√°rias linhas.


# Transa√ß√µes em SQL s√£o essencialmente um conjunto de opera√ß√µes que s√£o realizadas como uma unidade √∫nica e indivis√≠vel de trabalho. Elas s√£o extremamente √∫teis quando voc√™ precisa garantir que um conjunto de opera√ß√µes seja executado com sucesso, ou ent√£o nenhuma delas seja aplicada, mantendo a consist√™ncia dos dados no banco de dados. Em outras palavras, uma transa√ß√£o segue o princ√≠pio do "tudo ou nada".
Aqui est√£o os quatro princ√≠pios que regem as transa√ß√µes, conhecidos como propriedades ACID:
	- Atomicidade: Tudo ou nada. Se uma parte da transa√ß√£o falhar, tudo √© desfeito.
	- Consist√™ncia: Garante que o banco de dados passe de um estado consistente para outro.
	- Isolamento: Transa√ß√µes independentes entre si, evitando interfer√™ncias.
	- Durabilidade: Ap√≥s ser conclu√≠da, a transa√ß√£o persiste, mesmo em caso de falha de sistema.

	# Uma transa√ß√£o em SQL pode ser implementada usando comandos espec√≠ficos para garantir as propriedades ACID. Aqui est√° um exemplo pr√°tico para ilustrar:
	Imagine que voc√™ est√° lidando com uma transfer√™ncia banc√°ria, onde o dinheiro precisa ser debitado de uma conta e creditado em outra. Em SQL, o c√≥digo poderia ser assim:
	Aqui est√° o que acontece:
		- BEGIN TRANSACTION: Inicia a transa√ß√£o. A partir daqui, todas as opera√ß√µes ficam "pendentes" at√© que sejam confirmadas ou revertidas.
		- UPDATE: Realiza as opera√ß√µes necess√°rias, como debitar e creditar valores em diferentes contas.
		- COMMIT: Finaliza a transa√ß√£o, confirmando que as mudan√ßas devem ser aplicadas de forma permanente.

	Se algo der errado no meio do processo (por exemplo, uma falha no sistema ou um erro em uma das opera√ß√µes), voc√™ pode desfazer as altera√ß√µes usando o comando ROLLBACK. Veja o exemplo:
	BEGIN TRANSACTION;
		-- Debitar da conta de origem
		UPDATE contas
		SET saldo = saldo - 100
		WHERE id_conta = 1;

		-- Simulando um erro (exemplo: saldo insuficiente na conta de destino)
		IF (SELECT saldo FROM contas WHERE id_conta = 2) < 100
		BEGIN
				ROLLBACK;
				PRINT 'Erro: Saldo insuficiente!';
				RETURN;
		END;

		-- Creditar na conta de destino
		UPDATE contas
		SET saldo = saldo + 100
		WHERE id_conta = 2;
	COMMIT;


# Locking em Acesso Concomitante de Transa√ß√µes" refere-se aos mecanismos usados para gerenciar o acesso simult√¢neo aos dados em um banco de dados, garantindo consist√™ncia e integridade durante transa√ß√µes concorrentes.
		
	Quando m√∫ltiplas transa√ß√µes ocorrem ao mesmo tempo, o locking (bloqueio) previne conflitos, como dois usu√°rios tentando atualizar o mesmo registro simultaneamente. Existem diferentes tipos de locks, como:
	- Locks Compartilhados: Permitem que m√∫ltiplas transa√ß√µes leiam os mesmos dados, mas impedem modifica√ß√µes.
	- Locks Exclusivos: Garantem que apenas uma transa√ß√£o possa modificar os dados, bloqueando outras de ler ou escrever.
	- Locks de Atualiza√ß√£o: Usados quando uma transa√ß√£o pretende modificar os dados, mas ainda n√£o o fez.

	Esses locks s√£o fundamentais para manter as propriedades ACID (Atomicidade, Consist√™ncia, Isolamento, Durabilidade) das transa√ß√µes. Por exemplo, se dois usu√°rios tentarem comprar o √∫ltimo item em estoque ao mesmo tempo, o locking assegura que apenas uma transa√ß√£o tenha sucesso, evitando inconsist√™ncias.

# Leitura & Escrita de Item
	1. read_item(x)
	Este termo representa uma opera√ß√£o de leitura de um item espec√≠fico em uma transa√ß√£o. Em outras palavras, read_item(x) refere-se ao ato de buscar ou acessar o valor atual de um item (como um dado ou registro no banco de dados). Ap√≥s a execu√ß√£o, o valor de x √© disponibilizado para ser usado na transa√ß√£o.
	Exemplo: Se voc√™ tem um sistema banc√°rio e deseja verificar o saldo de uma conta antes de realizar uma opera√ß√£o, a transa√ß√£o usaria read_item(saldo) para acessar o valor atual do saldo.

	2. write_item(x)
	Este termo representa uma opera√ß√£o de escrita ou atualiza√ß√£o de um item espec√≠fico no banco de dados. O write_item(x) √© usado quando uma transa√ß√£o modifica o valor de um item e salva essa altera√ß√£o no banco de dados.
	Exemplo: No caso de uma transfer√™ncia banc√°ria, quando uma transa√ß√£o diminui o saldo de uma conta ou aumenta o saldo de outra, a transa√ß√£o executa write_item(saldo) para aplicar as mudan√ßas.
	
	# Ciclo em uma transa√ß√£o:
		Em uma transa√ß√£o t√≠pica, primeiro ocorre uma opera√ß√£o de leitura (read_item(x)), seguida por algum tipo de processamento ou c√°lculo interno, e ent√£o, se necess√°rio, uma opera√ß√£o de escrita (write_item(x)).
	
	# Controle de concorr√™ncia:
		Essas opera√ß√µes s√£o fundamentais no controle de concorr√™ncia em transa√ß√µes, pois ajudam a determinar como os dados s√£o acessados e modificados por v√°rias transa√ß√µes simult√¢neas. Por exemplo:
			- read_item(x) pode bloquear um item para evitar que outro processo o modifique enquanto est√° sendo lido.
			- write_item(x) pode bloquear o item at√© que a transa√ß√£o seja confirmada ou revertida.

	Esses conceitos garantem que as propriedades ACID (Atomicidade, Consist√™ncia, Isolamento e Durabilidade) sejam mantidas durante o processamento de transa√ß√µes.

# O controle de concorr√™ncia em transa√ß√µes √© essencial para manter a integridade e a consist√™ncia dos dados em um sistema de banco de dados quando m√∫ltiplas transa√ß√µes est√£o ocorrendo simultaneamente. Ele garante que as propriedades ACID (Atomicidade, Consist√™ncia, Isolamento e Durabilidade) sejam preservadas, mesmo em cen√°rios de acesso concorrente.

	# Problemas que o controle de concorr√™ncia resolve:
		- Perda de Atualiza√ß√£o (Lost Update):- Quando duas ou mais transa√ß√µes atualizam o mesmo dado simultaneamente, e as mudan√ßas de uma transa√ß√£o sobrescrevem as de outra.

		- Leitura Suja (Dirty Read):- Quando uma transa√ß√£o l√™ dados que foram modificados, mas ainda n√£o confirmados por outra transa√ß√£o, podendo gerar inconsist√™ncias se a outra transa√ß√£o for revertida.

		- Leitura N√£o Repet√≠vel (Non-Repeatable Read):- Quando uma transa√ß√£o l√™ o mesmo dado mais de uma vez, mas obt√©m valores diferentes porque outra transa√ß√£o modificou esse dado entre as leituras.

		- Fantasmas (Phantom Reads):- Quando uma transa√ß√£o executa uma consulta duas vezes, mas obt√©m conjuntos de resultados diferentes devido a inser√ß√µes ou exclus√µes feitas por outra transa√ß√£o.

	# T√©cnicas de Controle de Concorr√™ncia:
		- Bloqueios (Locks):- Bloqueios Compartilhados (Shared Locks): Permitem que v√°rias transa√ß√µes leiam um dado ao mesmo tempo, mas impedem modifica√ß√µes enquanto o bloqueio estiver ativo.
		- Bloqueios Exclusivos (Exclusive Locks): Permitem que apenas uma transa√ß√£o leia e modifique o dado, impedindo o acesso de outras transa√ß√µes.

		- Controle de Concorr√™ncia com Carimbo de Tempo (Timestamp):- Cada transa√ß√£o recebe um carimbo de tempo (timestamp) √∫nico e √© executada com base em sua ordem de chegada. Transa√ß√µes mais antigas t√™m prioridade sobre as mais novas.

		- Controle Pessimista:- Assume que sempre haver√° conflito, ent√£o bloqueios s√£o aplicados preventivamente para evitar problemas.

		- Controle Otimista:- Assume que os conflitos s√£o raros. As transa√ß√µes ocorrem sem bloqueios, mas h√° uma valida√ß√£o no momento do commit para garantir que n√£o houve conflitos.

		- Serializa√ß√£o:- As transa√ß√µes s√£o ordenadas de forma que o resultado final seja o mesmo que se as transa√ß√µes tivessem sido executadas uma de cada vez (serializadamente).

	# Ferramentas pr√°ticas em bancos de dados:
		A maioria dos sistemas de gerenciamento de bancos de dados (DBMS) modernos, como MySQL, PostgreSQL e SQL Server, oferecem suporte a n√≠veis de isolamento para controlar concorr√™ncia:
			- READ UNCOMMITTED: Permite leitura de dados n√£o confirmados (mais suscet√≠vel a problemas).
			- READ COMMITTED: Garante que apenas dados confirmados sejam lidos.
			- REPEATABLE READ: Garante que dados lidos por uma transa√ß√£o n√£o sejam modificados at√© o final dela.
			- SERIALIZABLE: O n√≠vel mais restritivo, garantindo execu√ß√£o completamente isolada.

	# Ending transa√ß√£o
		- Ending the server
		- Instru√ß√£o: alter table
		- Comando de start
		- Detec√ß√£o de deadLock

	# Transa√ß√£o Concorrente:
		Ocorre quando duas ou mais transa√ß√µes est√£o simultaneamente tentando acessar ou modificar o mesmo registro no banco de dados. O MySQL utiliza mecanismos como bloqueios (locks) e n√≠veis de isolamento para lidar com essas situa√ß√µes.
		- Identifica√ß√£o:
		O MySQL identifica uma transa√ß√£o concorrente se:- Ambas est√£o tentando executar write_item ou modificar o mesmo registro.
		- Uma transa√ß√£o tenta acessar um dado que est√° bloqueado por outra transa√ß√£o (por exemplo, em um bloqueio exclusivo).

		- Como o MySQL gerencia:- Utiliza locks (bloqueios compartilhados ou exclusivos) para controlar o acesso ao registro em quest√£o. Exemplo:- Um bloqueio exclusivo impede que outra transa√ß√£o modifique o mesmo registro at√© o COMMIT ou ROLLBACK.

		- Depende do n√≠vel de isolamento configurado. Por exemplo, em SERIALIZABLE, transa√ß√µes concorrentes s√£o completamente isoladas umas das outras.

		- Exemplo pr√°tico:- Transa√ß√£o 1: Atualiza o saldo da conta A (UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1).
		- Transa√ß√£o 2: Tenta ler ou modificar o saldo da mesma conta (SELECT saldo FROM contas WHERE id_conta = 1). Nesse caso, o MySQL detecta concorr√™ncia e aplica os bloqueios necess√°rios para evitar conflitos.

	# Transa√ß√£o Sequencial:
		Ocorre quando duas ou mais transa√ß√µes est√£o operando em registros diferentes ou em momentos distintos, sem interferir diretamente uma na outra.
		- Identifica√ß√£o:
		O MySQL entende que transa√ß√µes s√£o sequenciais quando:- Cada transa√ß√£o opera em registros completamente diferentes (n√£o h√° conflito de acesso ao mesmo dado).
		- As transa√ß√µes s√£o executadas uma ap√≥s a outra, sem sobreposi√ß√£o no tempo.

		- Como o MySQL gerencia:- No caso de transa√ß√µes que n√£o t√™m interdepend√™ncia, o MySQL processa as opera√ß√µes normalmente, sem necessidade de bloqueios espec√≠ficos.
		- N√£o h√° espera ou necessidade de gerenciamento especial, pois os dados acessados/modificados por cada transa√ß√£o n√£o se sobrep√µem.

		- Exemplo pr√°tico:- Transa√ß√£o 1: Atualiza o saldo da conta A (UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1).
		- Transa√ß√£o 2: Atualiza o saldo da conta B (UPDATE contas SET saldo = saldo - 50 WHERE id_conta = 2). Como essas transa√ß√µes operam em registros distintos, o MySQL n√£o identifica concorr√™ncia e executa ambas normalmente.

	# Diferen√ßa entre as duas:
		- Concorr√™ncia: √â marcada pela disputa pelo acesso ao mesmo recurso ou dado. O MySQL aplica mecanismos de controle para evitar inconsist√™ncias.
		- Sequencialidade: Representa transa√ß√µes que n√£o interferem uma na outra, permitindo execu√ß√£o tranquila sem necessidade de bloqueios ou controles complexos.

	# Savepoint em transa√ß√µes √© um recurso do SQL que permite definir pontos intermedi√°rios dentro de uma transa√ß√£o. Com o SAVEPOINT, voc√™ pode marcar um estado espec√≠fico e, se necess√°rio, reverter apenas parte da transa√ß√£o usando ROLLBACK TO SAVEPOINT, em vez de desfazer tudo com um ROLLBACK completo.
		Como funciona o SAVEPOINT?
			- Definir um ponto intermedi√°rio na transa√ß√£o:- Permite que partes espec√≠ficas de uma transa√ß√£o sejam revertidas sem cancelar a transa√ß√£o inteira.

			- Fazer rollback at√© um SAVEPOINT espec√≠fico:- Em caso de erro, voc√™ pode desfazer apenas at√© um determinado ponto, sem perder todas as altera√ß√µes anteriores.

			- Excluir um SAVEPOINT:- Se um ponto intermedi√°rio n√£o for mais necess√°rio, ele pode ser removido com RELEASE SAVEPOINT.

		Benef√≠cios do SAVEPOINT
			‚úÖ Permite um controle mais refinado sobre revers√£o de transa√ß√µes.
			‚úÖ Evita ROLLBACK completo, mantendo as opera√ß√µes anteriores intactas.
			‚úÖ √ötil para transa√ß√µes complexas, onde nem todas as opera√ß√µes precisam ser desfeitas em caso de erro.

	# Por que ocorre uma transa√ß√£o em espera no MySQL?
		Isso acontece em cen√°rios de concorr√™ncia, quando duas ou mais transa√ß√µes tentam modificar ou ler o mesmo registro. Se uma transa√ß√£o j√° possui um bloqueio sobre esse recurso, outra transa√ß√£o que precise dele ficar√° em espera at√© que o bloqueio seja liberado.
	
	# Tipos de bloqueios que causam espera:
		- Bloqueio Exclusivo (Exclusive Lock)- Se uma transa√ß√£o j√° est√° modificando um registro com UPDATE ou DELETE, qualquer outra transa√ß√£o tentando modificar esse mesmo registro ficar√° esperando o primeiro commit ou rollback.

		- Bloqueio Compartilhado (Shared Lock)- Uma transa√ß√£o que est√° apenas lendo (SELECT ... FOR UPDATE) pode bloquear outras transa√ß√µes que tentam escrever no mesmo registro.

		- Deadlock (Impasse)- Se duas transa√ß√µes dependem de um recurso bloqueado pela outra, ocorre um deadlock, e MySQL escolhe uma das transa√ß√µes para ser cancelada.

	Exemplo pr√°tico de transa√ß√£o esperando no MySQL
		Suponha que duas transa√ß√µes tentam modificar o mesmo registro simultaneamente:
		Transa√ß√£o 1:
			START TRANSACTION;
			UPDATE contas SET saldo = saldo - 100 WHERE id_conta = 1;
			-- Transa√ß√£o 1 ainda n√£o fez COMMIT

		Transa√ß√£o 2:
			START TRANSACTION;
			UPDATE contas SET saldo = saldo + 100 WHERE id_conta = 1;
			-- Fica em espera porque Transa√ß√£o 1 tem um bloqueio no registro!
	
		A Transa√ß√£o 2 n√£o pode continuar at√© que a Transa√ß√£o 1 finalize com um COMMIT ou ROLLBACK.

	# Como resolver ou evitar espera em transa√ß√µes no MySQL?
		- Definir um tempo m√°ximo de espera (innodb_lock_wait_timeout):
			SET innodb_lock_wait_timeout = 5; -- Tempo m√°ximo de espera em segundos
			Assim, se uma transa√ß√£o ficar bloqueada por mais de 5 segundos, ela falha em vez de esperar indefinidamente.
		
		- Usar NOWAIT ou SKIP LOCKED para evitar bloqueio:
			NOWAIT: Se o recurso estiver bloqueado, a transa√ß√£o falha imediatamente, sem esperar
				SELECT * FROM contas WHERE id_conta = 1 FOR UPDATE NOWAIT;
			
			- SKIP LOCKED: Ignora registros bloqueados e continua a execu√ß√£o.
				SELECT * FROM contas WHERE id_conta = 1 FOR UPDATE SKIP LOCKED;

		- Evitar Deadlocks organizando a ordem das opera√ß√µes entre transa√ß√µes concorrentes.- Certifique-se de que todas as transa√ß√µes que envolvem m√∫ltiplos registros sigam sempre a mesma ordem para evitar depend√™ncias circulares.

		# Conclus√£o
			Transa√ß√µes em espera no MySQL ocorrem devido a bloqueios em registros sendo modificados por outras transa√ß√µes. Para evitar problemas, voc√™ pode ajustar tempos de espera (innodb_lock_wait_timeout), usar estrat√©gias como NOWAIT ou SKIP LOCKED, e garantir que as transa√ß√µes sigam uma ordem l√≥gica.





